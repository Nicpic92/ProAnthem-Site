# --- START OF FILE netlify.toml ---
# This is the final, syntactically correct version.

[build]
  publish = "public"
  functions = "netlify/functions"

# This block applies settings to ALL serverless functions.
# The ."*" is a wildcard.
[functions."*"]
  # Increase the function timeout to 20 seconds.
  timeout = 20

#### **Step 2: The Final, Robust `login.js`**

This version adds a `finally` block. This is a crucial best practice. It guarantees that the database connection is closed, whether the function succeeds, fails, or times out. This prevents your database from running out of available connections.

**Replace the entire contents of `netlify/functions/login.js` with this:**

```javascript
// --- START OF FILE netlify/functions/login.js ---

const { Client } = require('pg');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const JWT_SECRET = process.env.JWT_SECRET;

exports.handler = async (event) => {
    if (event.httpMethod !== 'POST') {
        return { statusCode: 405, body: JSON.stringify({ message: 'Method Not Allowed' }) };
    }

    const { email, password } = JSON.parse(event.body);
    if (!email || !password) {
        return { statusCode: 400, body: JSON.stringify({ message: 'Email and password are required.' }) };
    }

    const client = new Client({
        connectionString: process.env.DATABASE_URL,
        ssl: { rejectUnauthorized: false }
    });

    try {
        await client.connect();
        
        const userQuery = `
            SELECT 
                u.email, u.password_hash, u.first_name, u.band_id, u.password_reset_required,
                r.name AS role_name,
                r.can_access_tool,
                r.song_limit,
                r.can_manage_band,
                r.can_use_setlists,
                r.can_use_stems
            FROM users u
            JOIN roles r ON u.role_id = r.id
            WHERE u.email = $1;
        `;
        const { rows: [user] } = await client.query(userQuery, [email.toLowerCase()]);

        if (!user || !await bcrypt.compare(password, user.password_hash)) {
            return { statusCode: 401, body: JSON.stringify({ message: 'Invalid credentials.' }) };
        }
        
        const tokenPayload = {
            user: {
                email: user.email, 
                name: user.first_name,
                band_id: user.band_id,
                force_reset: user.password_reset_required || false,
                permissions: {
                    role: user.role_name,
                    can_access_tool: user.can_access_tool,
                    song_limit: user.song_limit,
                    can_manage_band: user.can_manage_band,
                    can_use_setlists: user.can_use_setlists,
                    can_use_stems: user.can_use_stems
                }
            }
        };
        
        const token = jwt.sign(tokenPayload, JWT_SECRET, { expiresIn: '1d' });

        if(user.password_reset_required) {
            await client.query('UPDATE users SET password_reset_required = FALSE WHERE email = $1', [user.email]);
        }
        
        return { statusCode: 200, body: JSON.stringify({ message: 'Login successful.', token: token }) };

    } catch (error) {
        console.error('Login Function Error:', error);
        return { statusCode: 500, body: JSON.stringify({ message: `Internal Server Error: ${error.message}` }) };
    } finally {
        // This block ensures the database connection is ALWAYS closed.
        if (client) {
            await client.end();
        }
    }
};
