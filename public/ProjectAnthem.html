<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Anthem - Block Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        body { font-family: Inter, system-ui, sans-serif; background-color: #242424; color: rgba(255, 255, 255, 0.87); }
        .form-input, .form-select, .form-textarea { background: #2f2f2f; border: 1px solid #555; border-radius: 6px; padding: 0.5rem 1rem; color: white; width: 100%; }
        .live-preview { font-family: 'Courier New', Courier, monospace; line-height: 1.6; white-space: pre; background-color: #1e1e1e; padding: 1rem; border-radius: 6px; border: 1px solid #4a4a4a; }
        .live-preview-chords { color: #f2c94c; }
        .tab-preview { margin-top: 1rem; border-top: 1px dashed #4a4a4a; padding-top: 1rem; color: #a5b4fc; }
        .btn { border: 1px solid transparent; padding: 0.6em 1.2em; font-size: 1em; font-weight: 500; cursor: pointer; transition: background-color 0.25s; border-radius: 8px; }
        .btn-sm { padding: 0.3em 0.8em; font-size: 0.9em; }
        .btn-primary { background-color: #535bf2; color: white; } .btn-primary:hover { background-color: #646cff; }
        .btn-secondary { background-color: #4b5563; color: white; } .btn-secondary:hover { background-color: #6b7280; }
        .btn-danger { background-color: #b91c1c; color: white; } .btn-danger:hover { background-color: #dc2626; }
        .hidden { display: none; }
        .song-block { background-color: #2d3748; border: 1px solid #4a5568; border-radius: 8px; margin-bottom: 1rem; }
        .block-header { background-color: #4a5568; padding: 0.5rem 1rem; display: flex; justify-content: space-between; align-items: center; cursor: grab; border-top-left-radius: 7px; border-top-right-radius: 7px; }
        .block-header:active { cursor: grabbing; }
        .block-content { padding: 1rem; }
        .fretboard-wrapper { overflow-x: auto; border: 1px solid #555; border-radius: 6px; }
        .fretboard-string { stroke: #9ca3af; stroke-width: 2px; }
        .fretboard-note { fill: #facc15; cursor: pointer; }
        .fretboard-note-text { fill: #111827; font-weight: bold; pointer-events: none; }
        .queue-pill { background-color: #374151; padding: 2px 8px; border-radius: 12px; font-size: 0.9em; }
        .queue-pill.next { background-color: #535bf2; font-weight: bold; }
        .form-textarea.placement-mode { cursor: crosshair; }
        .btn-record { background-color: #ef4444; color: white; } .btn-record:hover:not(:disabled) { background-color: #f87171; }
        .btn-record.recording { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .7; } }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 50; }
        .modal-content { background: #2d3748; padding: 2rem; border-radius: 8px; width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto;}
        .sortable-ghost { opacity: 0.4; background: #4a5568; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="access-denied" class="hidden text-center p-20">
        <h2 class="text-3xl font-bold text-red-500">Access Denied</h2>
        <p class="mt-4 text-lg">You must be logged in to use Project Anthem.</p>
        <a href="/proanthem_index.html" class="mt-6 inline-block bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg">Log In or Sign Up</a>
    </div>

    <div id="tool-content" class="max-w-6xl mx-auto hidden">
        <header class="border-b border-gray-700 pb-4 mb-6 flex justify-between items-center">
             <a href="/" class="flex items-center space-x-4">
                <img src="/assets/logo_pa.jpg" alt="ProAnthem Logo" class="h-12">
                <h1 class="text-4xl font-bold">Project Anthem</h1>
            </a>
            <button id="logoutBtn" class="btn btn-secondary">Log Out</button>
        </header>
        <main class="grid grid-cols-1 md:grid-cols-4 gap-8">
            <aside class="md:col-span-1">
                <div class="space-y-6 sticky top-8">
                    <div>
                        <label for="songSelector" class="block text-sm font-medium text-gray-300 mb-1">Load Song</label>
                        <select id="songSelector" class="form-select"></select>
                    </div>
                    <div class="space-y-2">
                        <button id="saveBtn" class="btn btn-primary w-full">Save Song</button>
                        <button id="setlistBtn" class="btn btn-secondary w-full">Setlists</button>
                        <button id="exportPdfBtn" class="btn btn-secondary w-full">Export Song as PDF</button>
                        <button id="deleteBtn" class="btn btn-danger w-full">Delete Song</button>
                        <div id="statusMessage" class="text-center text-sm text-gray-400 h-4"></div>
                    </div>
                     <div class="space-y-3 pt-4 border-t border-gray-700">
                        <h3 class="font-semibold text-lg">Chord Palette</h3>
                        <p class="text-xs text-gray-400">Click to insert. Ctrl/Cmd+Click to add to queue.</p>
                        <div id="chordPalette" class="flex flex-wrap gap-2"></div>
                        <div class="flex gap-2">
                            <input type="text" id="newChordInput" class="form-input text-sm" placeholder="e.g. F#m7">
                            <button id="addChordBtn" class="btn btn-secondary btn-sm whitespace-nowrap">Add</button>
                        </div>
                    </div>
                     <div class="space-y-3 pt-4 border-t border-gray-700">
                        <h3 class="font-semibold text-lg">Musical Settings</h3>
                        <div class="text-right">
                            <label for="tuningSelector" class="block text-sm font-medium text-gray-400 mb-1">Tuning</label>
                            <select id="tuningSelector" class="form-select form-input text-sm"></select>
                        </div>
                        <div class="text-right">
                            <label for="capoFretInput" class="block text-sm font-medium text-gray-400 mb-1">Capo Fret</label>
                            <input type="number" id="capoFretInput" class="form-input text-sm w-24 ml-auto" value="0" min="0" max="12">
                        </div>
                        <div class="text-right">
                                <label class="block text-sm font-medium text-gray-400 mb-1">Transpose All Chords</label>
                                <div class="flex items-center gap-2 justify-end">
                                    <button id="transposeDownBtn" class="btn btn-secondary btn-sm">-</button>
                                    <span id="transposeStatus" class="font-bold text-lg w-8 text-center">0</span>
                                    <button id="transposeUpBtn" class="btn btn-secondary btn-sm">+</button>
                                </div>
                            </div>
                    </div>
                </div>
            </aside>
            <div class="md:col-span-3 space-y-4">
                <input type="text" id="titleInput" class="form-input text-xl" placeholder="Song Title">
                <input type="text" id="artistInput" class="form-input" placeholder="Artist Name">
                
                <div id="audioSection" class="p-4 bg-gray-900 rounded-md space-y-3">
                    <h3 class="text-lg font-semibold">Voice Memo</h3>
                    <div id="audioPlayerContainer" class="hidden">
                        <audio id="audioPlayer" controls class="w-full"></audio>
                    </div>
                    <div class="flex items-center gap-4">
                        <button id="recordBtn" class="btn btn-record">Record</button>
                        <button id="stopBtn" class="btn btn-secondary" disabled>Stop</button>
                        <span id="recordingStatus" class="text-gray-400"></span>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-semibold mb-2">Live Preview</h3>
                    <div id="livePreview" class="live-preview min-h-[100px]"></div>
                </div>
                
                <div class="mb-2">
                    <label class="block text-sm font-medium text-gray-400 mb-1">Chord Queue (Click in a lyrics block to place)</label>
                    <div class="flex items-center gap-2 p-2 bg-gray-900 rounded-md min-h-[40px]">
                        <div id="chordQueue" class="flex flex-wrap gap-2 flex-grow"></div>
                        <button id="clearQueueBtn" class="btn btn-danger btn-sm">Clear</button>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-semibold mb-2">Song Builder</h3>
                    <div id="song-blocks-container" class="space-y-4"></div>
                    <div id="add-block-buttons" class="mt-4 flex flex-wrap gap-2"></div>
                </div>
            </div>
        </main>
    </div>

    <div id="setlistModal" class="modal-overlay hidden">
        <div class="modal-content space-y-4">
            <div class="flex justify-between items-center"><h2 class="text-2xl font-bold">Setlist Manager</h2><button id="closeSetlistModalBtn" class="text-2xl">&times;</button></div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="setlistSelector" class="block text-sm font-medium text-gray-300 mb-1">Select Setlist</label>
                    <select id="setlistSelector" class="form-select"></select>
                </div>
                <div>
                    <label for="newSetlistInput" class="block text-sm font-medium text-gray-300 mb-1">Or Create New</label>
                    <div class="flex gap-2"><input type="text" id="newSetlistInput" class="form-input"><button id="createSetlistBtn" class="btn btn-primary">Create</button></div>
                </div>
            </div>
            <div id="setlistDetailsSection" class="hidden space-y-3 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-lg font-semibold">Gig Details</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label for="setlistVenue" class="block text-sm">Venue</label><input type="text" id="setlistVenue" class="form-input"></div>
                    <div><label for="setlistDate" class="block text-sm">Date</label><input type="date" id="setlistDate" class="form-input"></div>
                </div>
                <div><label for="setlistLogoUrl" class="block text-sm">Band Logo Image URL (for watermark)</label><input type="text" id="setlistLogoUrl" class="form-input" placeholder="https://.../logo.png"></div>
                <div><label for="setlistNotes" class="block text-sm">Notes</label><textarea id="setlistNotes" class="form-input" rows="2"></textarea></div>
                <div class="text-right"><button id="saveSetlistDetailsBtn" class="btn btn-primary btn-sm">Save Details</button></div>
            </div>
            <div class="bg-gray-800 p-4 rounded-md">
                <h3 id="currentSetlistTitle" class="text-xl font-semibold mb-2">Select a setlist</h3>
                <p class="text-sm text-gray-400 mb-2">Drag and drop songs to reorder.</p>
                <ul id="songsInSetlist" class="space-y-2"></ul>
            </div>
            <div class="flex justify-end gap-2">
                <button id="printSetlistBtn" class="btn btn-secondary" disabled>Print Setlist</button>
                <button id="addSongToSetlistBtn" class="btn btn-primary" disabled>Add Current Song to Setlist</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const token = localStorage.getItem('user_token');
        if (!token) {
            document.getElementById('tool-content').classList.add('hidden');
            document.getElementById('access-denied').classList.remove('hidden');
        } else {
            document.getElementById('tool-content').classList.remove('hidden');
            document.getElementById('access-denied').classList.add('hidden');
            initializeApp();
        }
    });

    function initializeApp() {
        let songData = { id: null, title: '', artist: '', audio_url: null, song_blocks: [] };
        let musicalContext = { tuning: 'E_STANDARD', capo: 0, transpose: 0 };
        let chordQueue = [];
        let chordQueueIndex = 0;
        let lastFocusedLyricsBlock = null;
        let mediaRecorder; 
        let audioChunks = [];

        const titleInput = document.getElementById('titleInput');
        const artistInput = document.getElementById('artistInput');
        const songBlocksContainer = document.getElementById('song-blocks-container');
        const addBlockButtonsContainer = document.getElementById('add-block-buttons');
        const livePreview = document.getElementById('livePreview');
        const tuningSelector = document.getElementById('tuningSelector');
        const capoFretInput = document.getElementById('capoFretInput');
        const songSelector = document.getElementById('songSelector');
        const saveBtn = document.getElementById('saveBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const exportPdfBtn = document.getElementById('exportPdfBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const statusMessage = document.getElementById('statusMessage');
        const chordPalette = document.querySelector('#sidebar #chordPalette');
        const newChordInput = document.querySelector('#sidebar #newChordInput');
        const addChordBtn = document.querySelector('#sidebar #addChordBtn');
        const transposeDownBtn = document.getElementById('transposeDownBtn');
        const transposeUpBtn = document.getElementById('transposeUpBtn');
        const transposeStatus = document.getElementById('transposeStatus');
        const chordQueueDiv = document.getElementById('chordQueue');
        const clearQueueBtn = document.getElementById('clearQueueBtn');
        const setlistBtn = document.getElementById('setlistBtn');
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const audioPlayerContainer = document.getElementById('audioPlayerContainer');
        const audioPlayer = document.getElementById('audioPlayer');
        const setlistModal = document.getElementById('setlistModal');
        const closeSetlistModalBtn = document.getElementById('closeSetlistModalBtn');
        const createSetlistBtn = document.getElementById('createSetlistBtn');
        const addSongToSetlistBtn = document.getElementById('addSongToSetlistBtn');
        const printSetlistBtn = document.getElementById('printSetlistBtn');
        const newSetlistInput = document.getElementById('newSetlistInput');
        const songsInSetlist = document.getElementById('songsInSetlist');
        
        const TUNINGS = { E_STANDARD: { name: "E Standard", offset: 0 }, EB_STANDARD: { name: "Eb Standard", offset: -1 }, D_STANDARD: { name: "D Standard", offset: -2 }, DROP_D: { name: "Drop D", offset: 0 }, DROP_C: { name: "Drop C", offset: -2 } };
        const STRING_CONFIG = {
            6: { names: ['e', 'B', 'G', 'D', 'A', 'E'], height: 180, stringSpacing: 28 },
            7: { names: ['e', 'B', 'G', 'D', 'A', 'E', 'B'], height: 210, stringSpacing: 28 },
            8: { names: ['e', 'B', 'G', 'D', 'A', 'E', 'B', 'F#'], height: 240, stringSpacing: 28 }
        };
        const FRETBOARD_CONFIG = { frets: 24, width: 8000, nutWidth: 15, fretSpacing: 80, dotFrets: [3, 5, 7, 9, 12, 15, 17, 19, 21, 24], dotRadius: 5, noteRadius: 11 };
        const sharpScale = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
        const CLOUDINARY_CLOUD_NAME = 'dawbku2eq';
        const CLOUDINARY_UPLOAD_PRESET = 'project-anthem-unsigned';

        const api = { 
            request: async (endpoint, options = {}) => {
                const token = localStorage.getItem('user_token');
                if (!token) { setStatus('You are not logged in.', true); window.location.href = '/proanthem_index.html'; throw new Error('No token found'); }
                const url = `/api${endpoint}`;
                const config = { headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}`}, ...options };
                 if(options.body) config.body = options.body;
                 if(options.method) config.method = options.method;
                const response = await fetch(url, config);
                if (!response.ok) {
                    if (response.status === 401) { setStatus('Session expired. Please log in.', true); localStorage.removeItem('user_token'); window.location.href = '/proanthem_index.html'; }
                    const err = await response.json().catch(() => ({ message: 'API Error' })); throw new Error(err.message);
                }
                return response.status === 204 ? null : response.json();
            },
            getSheets: () => api.request('/lyric-sheets', { method: 'GET' }),
            getSheet: (id) => api.request(`/lyric-sheets/${id}`, { method: 'GET' }),
            createSheet: (data) => api.request('/lyric-sheets', { method: 'POST', body: JSON.stringify(data) }),
            updateSheet: (id, data) => api.request(`/lyric-sheets/${id}`, { method: 'PUT', body: JSON.stringify(data) }),
            deleteSheet: (id) => api.request(`/lyric-sheets/${id}`, { method: 'DELETE' }),
            getChords: () => api.request('/chords', { method: 'GET' }),
            createChord: (data) => api.request('/chords', { method: 'POST', body: JSON.stringify(data) }),
            getSetlists: () => api.request('/setlists', { method: 'GET' }),
            getSetlist: (id) => api.request(`/setlists/${id}`, { method: 'GET' }),
            createSetlist: (data) => api.request('/setlists', { method: 'POST', body: JSON.stringify(data) }),
            addSongToSetlist: (setlistId, songId) => api.request(`/setlists/${setlistId}/songs`, { method: 'POST', body: JSON.stringify({ song_id: songId }) }),
            removeSongFromSetlist: (setlistId, songId) => api.request(`/setlists/${setlistId}/songs/${songId}`, { method: 'DELETE' }),
            updateSetlistDetails: (id, data) => api.request(`/setlists/${id}`, { method: 'PUT', body: JSON.stringify(data) }),
            updateSetlistSongOrder: (id, song_ids) => api.request(`/setlists/${id}/songs`, { method: 'PUT', body: JSON.stringify({ song_ids }) }) 
        };
        
        function renderSongBlocks() {
            songBlocksContainer.innerHTML = '';
            (songData.song_blocks || []).forEach(block => {
                const blockEl = createBlockElement(block);
                songBlocksContainer.appendChild(blockEl);
            });
            renderAddBlockButtons();
            renderPreview();
            initializeSortable();
        }

        function createBlockElement(block) {
            const div = document.createElement('div');
            div.className = 'song-block';
            div.dataset.blockId = block.id;

            let contentHtml = '';
            let headerControls = '';
            if (block.type === 'lyrics') {
                contentHtml = `<textarea class="form-textarea lyrics-block" data-field="content" placeholder="Enter lyrics and [chords]...">${block.content || ''}</textarea>`;
            } else if (block.type === 'tab') {
                const numStrings = block.strings || 6;
                contentHtml = `<div class="fretboard-wrapper"><div id="fretboard-${block.id}"></div></div>`;
                headerControls = `
                    <div class="flex items-center gap-2">
                        <label for="strings-${block.id}" class="text-xs text-gray-300">Strings:</label>
                        <select id="strings-${block.id}" data-action="change-strings" class="form-select text-xs p-1" style="width: 70px;">
                            <option value="6" ${numStrings === 6 ? 'selected' : ''}>6</option>
                            <option value="7" ${numStrings === 7 ? 'selected' : ''}>7</option>
                            <option value="8" ${numStrings === 8 ? 'selected' : ''}>8</option>
                        </select>
                    </div>`;
            } else if (block.type === 'reference') {
                const originalBlock = songData.song_blocks.find(b => b.id === block.originalId);
                contentHtml = `<div class="p-4 bg-gray-800 rounded-md text-gray-400 italic">Reference to: ${originalBlock ? originalBlock.label : 'Unknown Section'}</div>`;
            }

            div.innerHTML = `
                <div class="block-header">
                    <div class="flex items-center gap-4">
                        <div class="flex items-center gap-2">
                           <span class="font-bold">${block.label}</span>
                           <span class="text-xs text-gray-400">(${block.type})</span>
                        </div>
                        ${headerControls}
                    </div>
                    <div>
                        <button class="btn-sm text-xs hover:underline" data-action="edit-label">Rename</button>
                        <button class="btn-sm text-red-400 hover:underline" data-action="delete">Delete</button>
                    </div>
                </div>
                <div class="block-content">${contentHtml}</div>
            `;
            
            if (block.type === 'tab') {
                setTimeout(() => drawFretboard(block.id), 0);
            }

            return div;
        }

        function renderAddBlockButtons() {
            const createdSections = songData.song_blocks.filter(b => b.type !== 'reference');
            let referenceButtonsHtml = '';
            if (createdSections.length > 0) {
                referenceButtonsHtml = `
                    <div class="relative inline-block text-left">
                        <button id="insert-ref-btn" class="btn btn-secondary">Insert Existing Section</button>
                        <div id="ref-dropdown" class="hidden origin-top-right absolute left-0 mt-2 w-56 rounded-md shadow-lg bg-gray-700 ring-1 ring-black ring-opacity-5 z-10">
                            <div class="py-1" role="menu" aria-orientation="vertical">
                                ${createdSections.map(b => `<a href="#" class="block px-4 py-2 text-sm text-gray-200 hover:bg-gray-600" data-original-id="${b.id}" role="menuitem">${b.label}</a>`).join('')}
                            </div>
                        </div>
                    </div>`;
            }

            addBlockButtonsContainer.innerHTML = `
                <button class="btn btn-secondary" data-action="add" data-type="lyrics"> + Verse </button>
                <button class="btn btn-secondary" data-action="add" data-type="lyrics"> + Chorus </button>
                <button class="btn btn-secondary" data-action="add" data-type="lyrics"> + Bridge </button>
                <button class="btn btn-secondary" data-action="add" data-type="tab"> + Tab Section </button>
                ${referenceButtonsHtml}
            `;
        }
        
        function renderPreview() {
            let previewHtml = '';
            (songData.song_blocks || []).forEach(block => {
                let blockToRender = block;
                if (block.type === 'reference') {
                    blockToRender = songData.song_blocks.find(b => b.id === block.originalId) || block;
                }
                
                previewHtml += `<h4 class="text-lg font-bold mt-4 text-gray-400">${block.label}</h4>`;
                
                if (blockToRender.type === 'lyrics') {
                    const lines = (blockToRender.content || '').split('\n');
                    lines.forEach(line => {
                        const parsed = parseLineForRender(line);
                        previewHtml += `<div class="live-preview-chords">${parsed.chordLine}</div><div>${parsed.lyricLine}</div>`;
                    });
                } else if (blockToRender.type === 'tab') {
                    previewHtml += `<div class="tab-preview">${renderTransposedTab(blockToRender)}</div>`;
                }
            });
            livePreview.innerHTML = previewHtml;
        }

        function drawFretboard(blockId) {
            const container = document.getElementById(`fretboard-${blockId}`);
            if (!container) return;
            const block = songData.song_blocks.find(b => b.id === blockId);
            if (!block) return;

            const numStrings = block.strings || 6;
            const stringConfig = STRING_CONFIG[numStrings];
            
            const { frets, width, nutWidth, fretSpacing, dotFrets, dotRadius } = FRETBOARD_CONFIG;
            const { height, stringSpacing } = stringConfig;

            let svgHTML = `<svg id="fretboard-svg-${blockId}" width="${width}" height="${height}" style="min-width: 100%;">`;
            svgHTML += `<rect class="fretboard-bg" width="${width}" height="${height}" />`;
            svgHTML += `<g id="fretboard-notes-group-${blockId}"></g>`;
            for (let i = 0; i < numStrings; i++) {
                const y = stringSpacing / 2 + i * stringSpacing;
                svgHTML += `<line class="fretboard-string" x1="0" y1="${y}" x2="${width}" y2="${y}" />`;
            }
            svgHTML += `<rect class="fretboard-nut" x="0" y="0" width="${nutWidth}" height="${height}" />`;
            for (let i = 1; i <= frets; i++) {
                const x = nutWidth + i * fretSpacing;
                svgHTML += `<line class="fretboard-fret" x1="${x}" y1="0" x2="${x}" y2="${height}" stroke="#4a5563" stroke-width="1" />`;
            }
            dotFrets.forEach(fret => {
                const x = nutWidth + (fret - 0.5) * fretSpacing;
                if (fret % 12 === 0) {
                    svgHTML += `<circle class="fretboard-dot" cx="${x}" cy="${stringSpacing * (numStrings / 4)}" r="${dotRadius}" />`;
                    svgHTML += `<circle class="fretboard-dot" cx="${x}" cy="${height - (stringSpacing * (numStrings / 4))}" r="${dotRadius}" />`;
                } else {
                    svgHTML += `<circle class="fretboard-dot" cx="${x}" cy="${height / 2}" r="${dotRadius}" />`;
                }
            });
            svgHTML += `<rect id="fretboard-target-zone-${blockId}" x="0" y="0" width="${width}" height="${height}" fill="transparent" class="fretboard-target-zone" />`;
            svgHTML += `</svg>`;
            container.innerHTML = svgHTML;
            drawNotesOnFretboard(blockId);
        }

        function drawNotesOnFretboard(blockId) {
            const block = songData.song_blocks.find(b => b.id === blockId);
            const notesGroup = document.getElementById(`fretboard-notes-group-${blockId}`);
            if (!notesGroup || !block || block.type !== 'tab') return;
            notesGroup.innerHTML = '';
            
            const numStrings = block.strings || 6;
            const stringConfig = STRING_CONFIG[numStrings];
            const totalOffset = (TUNINGS[musicalContext.tuning]?.offset ?? 0) + musicalContext.capo + musicalContext.transpose;

            (block.data?.notes || []).forEach((note, index) => {
                if (note.string >= numStrings) return;
                const transposedFret = note.fret - totalOffset;
                if (transposedFret < 0) return;

                const y = stringConfig.stringSpacing / 2 + note.string * stringConfig.stringSpacing;
                const x = (transposedFret === 0) 
                    ? FRETBOARD_CONFIG.nutWidth / 2 
                    : FRETBOARD_CONFIG.nutWidth + (transposedFret - 0.5) * FRETBOARD_CONFIG.fretSpacing + (note.position || 0);
                
                notesGroup.innerHTML += `
                    <g class="note-group">
                        <circle class="fretboard-note" cx="${x}" cy="${y}" r="${FRETBOARD_CONFIG.noteRadius}" data-note-index="${index}" data-block-id="${blockId}" />
                        <text class="fretboard-note-text" x="${x}" y="${y+1}">${transposedFret}</text>
                    </g>
                `;
            });
        }
        
        function getFretFromClick(evt, blockId) {
            const svg = document.getElementById(`fretboard-svg-${blockId}`);
            const block = songData.song_blocks.find(b => b.id === blockId);
            if (!svg || !block) return null;
            
            const numStrings = block.strings || 6;
            const stringConfig = STRING_CONFIG[numStrings];

            const pt = svg.createSVGPoint();
            pt.x = evt.clientX; pt.y = evt.clientY;
            const ctm = svg.getScreenCTM();
            if(!ctm) return null;
            const svgPoint = pt.matrixTransform(ctm.inverse());
            
            const stringIndex = Math.floor((svgPoint.y / stringConfig.stringSpacing));
            const fret = Math.round((svgPoint.x - FRETBOARD_CONFIG.nutWidth) / FRETBOARD_CONFIG.fretSpacing);
            
            if (stringIndex >= 0 && stringIndex < numStrings && fret >= 0 && fret <= FRETBOARD_CONFIG.frets) {
                return { string: stringIndex, fret, position: Math.round(svgPoint.x) };
            }
            return null;
        }

        function renderTransposedTab(tabBlock) {
            if (!tabBlock.data || !tabBlock.data.notes || tabBlock.data.notes.length === 0) return 'No tab data for this section.';
            
            const numStrings = tabBlock.strings || 6;
            const stringConfig = STRING_CONFIG[numStrings];
            const totalOffset = (TUNINGS[musicalContext.tuning]?.offset ?? 0) + musicalContext.capo + musicalContext.transpose;
            
            const positionMap = new Map();
            tabBlock.data.notes.forEach(note => {
                if (note.string >= numStrings) return;
                const transposedFret = note.fret - totalOffset;
                if (transposedFret < 0) return;
                const charPosition = Math.floor(note.position / 12);
                if (!positionMap.has(charPosition)) {
                    positionMap.set(charPosition, Array(numStrings).fill(null));
                }
                positionMap.get(charPosition)[note.string] = transposedFret;
            });
            
            if (positionMap.size === 0) return 'Notes out of range for current settings.';
            
            const sortedPositions = [...positionMap.keys()].sort((a,b) => a - b);
            const lines = stringConfig.names.map(name => `${name}|`);
            let lastCharPos = 1;
            
            sortedPositions.forEach(charPos => {
                const notesAtPos = positionMap.get(charPos);
                const padding = charPos - lastCharPos;
                if (padding > 0) lines.forEach((line, i) => lines[i] += '-'.repeat(padding));
                
                let maxFretWidth = 0;
                notesAtPos.forEach(fret => {
                    if (fret !== null) maxFretWidth = Math.max(maxFretWidth, String(fret).length);
                });
                
                lines.forEach((line, i) => {
                    const fret = notesAtPos[i];
                    lines[i] += (fret !== null) ? String(fret).padEnd(maxFretWidth, '-') : '-'.repeat(maxFretWidth);
                });
                lastCharPos = charPos + maxFretWidth;
            });
            
            const maxLength = Math.max(...lines.map(l => l.length));
            return lines.map(line => line.padEnd(maxLength, '-')).join('\n');
        }

        function updateBlockData(blockId, field, value) {
            const block = songData.song_blocks.find(b => b.id === blockId);
            if (block) {
                block[field] = value;
                renderPreview();
            }
        }
        
        async function loadSong(id) {
            if (!id) { initializeNewSong(); return; }
            setStatus('Loading song...');
            try {
                const data = await api.getSheet(id);
                if ((data.content || data.tab_content) && !data.song_blocks) {
                    setStatus('Migrating old song format...');
                    data.song_blocks = [];
                    if (data.content) {
                         data.song_blocks.push({
                            id: `block_${Date.now()}`, type: 'lyrics', label: 'Main Section', content: data.content
                        });
                    }
                    if (data.tab_content && data.tab_content.notes) {
                        data.song_blocks.push({
                            id: `block_${Date.now()+1}`, type: 'tab', label: 'Tab Section 1', data: data.tab_content, strings: 6
                        });
                    }
                }

                songData = {
                    id: data.id, title: data.title || '', artist: data.artist || '', audio_url: data.audio_url,
                    song_blocks: data.song_blocks || []
                };

                titleInput.value = songData.title;
                artistInput.value = songData.artist;
                renderSongBlocks();
                setStatus('Song loaded.');
            } catch (error) {
                setStatus(`Error loading song: ${error.message}`, true);
                initializeNewSong();
            }
        }

        function initializeNewSong() {
            songData = {
                id: null, title: '', artist: '', audio_url: null,
                song_blocks: [{
                    id: `block_${Date.now()}`,
                    type: 'lyrics',
                    label: 'Verse 1',
                    content: ''
                }]
            };
            titleInput.value = '';
            artistInput.value = '';
            songSelector.value = 'new';
            renderSongBlocks();
        }

        async function handleSave() {
            songData.title = titleInput.value || 'Untitled';
            songData.artist = artistInput.value || 'Unknown Artist';
            setStatus('Saving...');
            try {
                const payload = { ...songData };
                const savedSong = songData.id ? await api.updateSheet(songData.id, payload) : await api.createSheet(payload);
                songData.id = savedSong.id;
                setStatus('Saved successfully!');
                if (!songSelector.querySelector(`option[value="${savedSong.id}"]`)) { 
                    await loadSheetList();
                    songSelector.value = savedSong.id;
                }
            } catch (error) { setStatus(`Save failed: ${error.message}`, true); }
        }
        
        function initializeSortable() {
            if (songBlocksContainer.sortableInstance) songBlocksContainer.sortableInstance.destroy();
            songBlocksContainer.sortableInstance = new Sortable(songBlocksContainer, {
                animation: 150, handle: '.block-header', onEnd: (evt) => {
                    const [movedItem] = songData.song_blocks.splice(evt.oldIndex, 1);
                    songData.song_blocks.splice(evt.newIndex, 0, movedItem);
                    renderPreview();
                }
            });
        }
        
        function setStatus(message, isError = false) { statusMessage.textContent = message; statusMessage.style.color = isError ? '#ef4444' : '#9ca3af'; if (message) setTimeout(() => statusMessage.textContent = '', 3000); }
        function parseLineForRender(rawLine) { let chordLine = ''; let lyricLine = ''; const regex = /(\[[^\]]+\])|([^\[]+)/g; let match; if (!rawLine.trim()) return { chordLine: '&nbsp;', lyricLine: '&nbsp;' }; while ((match = regex.exec(rawLine)) !== null) { if (match[1]) { const chordName = match[1].slice(1, -1); chordLine += chordName; lyricLine += ' '.repeat(chordName.length); } if (match[2]) { chordLine += ' '.repeat(match[2].length); lyricLine += match[2]; } } return { chordLine: chordLine.trimEnd() || '&nbsp;', lyricLine: lyricLine.trimEnd() || '&nbsp;' }; }
        function populateTuningSelector() { for (const key in TUNINGS) { const option = document.createElement('option'); option.value = key; option.textContent = TUNINGS[key].name; tuningSelector.appendChild(option); } }
        async function loadSheetList() { try { const songs = await api.getSheets(); songs.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at)); songSelector.innerHTML = '<option value="new">-- Create New Song --</option>'; songs.forEach(s => { const o = document.createElement('option'); o.value = s.id; o.textContent = s.title || 'Untitled'; songSelector.appendChild(o); }); } catch (e) { setStatus('Failed to load songs.', true); } }
        async function handleDelete() { if (!songData.id) return; if (confirm(`Are you sure you want to delete "${songData.title}"?`)) { try { setStatus('Deleting...'); await api.deleteSheet(songData.id); setStatus('Song deleted.'); initializeNewSong(); await loadSheetList(); } catch (e) { setStatus('Failed to delete.', true); } } }
        function transposeChord(chord, amount) { const regex = /^([A-G][b#]?)(.*)/; const match = chord.match(regex); if (!match) return chord; let note = match[1]; let index = sharpScale.indexOf(note); if (index === -1) { const flatNotes = { 'Bb':'A#', 'Db':'C#', 'Eb':'D#', 'Gb':'F#', 'Ab':'G#'}; note = flatNotes[note] || note; index = sharpScale.indexOf(note); } if (index === -1) return chord; const newIndex = (index + amount + 12) % 12; return sharpScale[newIndex] + match[2]; }
        function updateTransposeStatus(steps) { musicalContext.transpose = steps; transposeStatus.textContent = steps > 0 ? `+${steps}` : steps; }
        function handleTranspose(amount) {
            updateTransposeStatus(musicalContext.transpose + amount);
            songData.song_blocks.forEach(block => {
                if (block.type === 'lyrics' && block.content) {
                    block.content = block.content.replace(/\[([^\]]+)\]/g, (match, chord) => `[${transposeChord(chord, amount)}]`);
                }
            });
            renderSongBlocks();
        }
        function renderChordQueue() {
            chordQueueDiv.innerHTML = '';
            if (chordQueue.length === 0) {
                document.querySelectorAll('.lyrics-block').forEach(el => el.classList.remove('placement-mode'));
                clearQueueBtn.disabled = true; return;
            }
            document.querySelectorAll('.lyrics-block').forEach(el => el.classList.add('placement-mode'));
            clearQueueBtn.disabled = false;
            chordQueue.forEach((name, index) => {
                const pill = document.createElement('span');
                pill.className = `queue-pill ${index === chordQueueIndex ? 'next' : ''}`;
                pill.textContent = name;
                chordQueueDiv.appendChild(pill);
            });
        }
        async function loadChords() { try { const chords = await api.getChords(); chordPalette.innerHTML = ''; chords.forEach(c => { const btn = document.createElement('button'); btn.className = 'btn btn-secondary btn-sm'; btn.onclick = (e) => { if (e.ctrlKey || e.metaKey) { chordQueue.push(c.name); renderChordQueue(); } else if (lastFocusedLyricsBlock) { const t = `[${c.name}]`; const p = lastFocusedLyricsBlock.selectionStart; lastFocusedLyricsBlock.value = lastFocusedLyricsBlock.value.slice(0, p) + t + lastFocusedLyricsBlock.value.slice(p); lastFocusedLyricsBlock.focus(); lastFocusedLyricsBlock.setSelectionRange(p + t.length, p + t.length); updateBlockData(lastFocusedLyricsBlock.closest('.song-block').dataset.blockId, 'content', lastFocusedLyricsBlock.value); }}; btn.textContent = c.name; chordPalette.appendChild(btn); }); } catch (e) { setStatus('Failed to load chords.', true); } }
        async function handleAddChord() { const name = newChordInput.value.trim(); if (!name) return; try { await api.createChord({ name }); newChordInput.value = ''; setStatus(`'${name}' added.`); await loadChords(); } catch (e) { setStatus(e.message, true); } }
        async function startRecording() { try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); mediaRecorder = new MediaRecorder(stream); mediaRecorder.ondataavailable = event => { audioChunks.push(event.data); }; mediaRecorder.onstop = handleSaveRecording; audioChunks = []; mediaRecorder.start(); recordBtn.textContent = 'Recording...'; recordBtn.classList.add('recording'); recordBtn.disabled = true; stopBtn.disabled = false; recordingStatus.textContent = 'Recording in progress.'; } catch (err) { setStatus('Microphone access denied.', true); console.error("Error accessing microphone:", err); } }
        function stopRecording() { if(mediaRecorder) mediaRecorder.stop(); recordBtn.textContent = 'Record'; recordBtn.classList.remove('recording'); recordBtn.disabled = false; stopBtn.disabled = true; recordingStatus.textContent = 'Processing...'; }
        async function handleSaveRecording() { const audioBlob = new Blob(audioChunks, { type: 'audio/webm' }); const formData = new FormData(); formData.append('file', audioBlob); formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET); const url = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/video/upload`; try { const response = await fetch(url, { method: 'POST', body: formData }); if (!response.ok) throw new Error('Upload to Cloudinary failed.'); const data = await response.json(); songData.audio_url = data.secure_url; await handleSave(); recordingStatus.textContent = 'Recording saved.'; document.getElementById('audioPlayerContainer').classList.remove('hidden'); document.getElementById('audioPlayer').src = data.secure_url; } catch (error) { setStatus('Failed to upload recording.', true); console.error("Upload error:", error); recordingStatus.textContent = ''; } }

        const musicalInputs = [tuningSelector, capoFretInput];
        musicalInputs.forEach(el => el.addEventListener('input', () => {
            musicalContext.tuning = tuningSelector.value;
            musicalContext.capo = parseInt(capoFretInput.value, 10) || 0;
            renderSongBlocks();
        }));
        transposeUpBtn.addEventListener('click', () => handleTranspose(1));
        transposeDownBtn.addEventListener('click', () => handleTranspose(-1));
        saveBtn.addEventListener('click', handleSave);
        deleteBtn.addEventListener('click', handleDelete);
        logoutBtn.addEventListener('click', () => { localStorage.removeItem('user_token'); localStorage.removeItem('userRole'); window.location.href = '/proanthem_index.html'; });
        addChordBtn.addEventListener('click', handleAddChord);
        newChordInput.addEventListener('keyup', (e) => e.key === 'Enter' && handleAddChord());
        clearQueueBtn.addEventListener('click', () => { chordQueue = []; chordQueueIndex = 0; renderChordQueue(); });
        songBlocksContainer.addEventListener('focusin', e => { if (e.target.classList.contains('lyrics-block')) lastFocusedLyricsBlock = e.target; });
        songBlocksContainer.addEventListener('input', e => { if (e.target.dataset.field) { const blockId = e.target.closest('.song-block').dataset.blockId; updateBlockData(blockId, e.target.dataset.field, e.target.value); } });
        songBlocksContainer.addEventListener('change', e => { if(e.target.dataset.action === 'change-strings') { const blockId = e.target.closest('.song-block').dataset.blockId; const block = songData.song_blocks.find(b => b.id === blockId); if(block) { block.strings = parseInt(e.target.value, 10); renderSongBlocks(); } }});
        songBlocksContainer.addEventListener('click', e => {
            const blockEl = e.target.closest('.song-block');
            if (!blockEl) return;
            const blockId = blockEl.dataset.blockId;
            const block = songData.song_blocks.find(b => b.id === blockId);
            if (e.target.dataset.action === 'delete') { if (confirm('Are you sure?')) { songData.song_blocks = songData.song_blocks.filter(b => b.id !== blockId); songData.song_blocks = songData.song_blocks.filter(b => !(b.type === 'reference' && b.originalId === blockId)); renderSongBlocks(); }} 
            else if (e.target.dataset.action === 'edit-label') { const newLabel = prompt('Enter new label:', block.label); if (newLabel) { block.label = newLabel; renderSongBlocks(); }}
            else if (e.target.classList.contains('fretboard-target-zone')) { const clickData = getFretFromClick(e, blockId); if (clickData) { const { string, fret, position } = clickData; const totalOffset = (TUNINGS[musicalContext.tuning]?.offset ?? 0) + musicalContext.capo + musicalContext.transpose; if (!block.data) block.data = { notes: [] }; block.data.notes.push({ string, fret: fret + totalOffset, position }); drawNotesOnFretboard(blockId); renderPreview(); }}
            else if (e.target.closest('.note-group')) { const noteIndex = parseInt(e.target.closest('.note-group').querySelector('.fretboard-note').dataset.noteIndex, 10); if (block?.data?.notes) { block.data.notes.splice(noteIndex, 1); drawNotesOnFretboard(blockId); renderPreview(); }}
            else if (e.target.classList.contains('lyrics-block') && chordQueue.length > 0) { e.preventDefault(); const textarea = e.target; const chordToPlace = chordQueue[chordQueueIndex]; const t = `[${chordToPlace}]`; const p = textarea.selectionStart; textarea.value = textarea.value.slice(0, p) + t + textarea.value.slice(p); textarea.focus(); const newPos = p + t.length; textarea.setSelectionRange(newPos, newPos); chordQueueIndex = (chordQueueIndex + 1) % chordQueue.length; updateBlockData(blockId, 'content', textarea.value); renderChordQueue(); }
        });
        addBlockButtonsContainer.addEventListener('click', e => {
            const target = e.target;
            if (target.id === 'insert-ref-btn') { document.getElementById('ref-dropdown').classList.toggle('hidden'); }
            else if (target.closest('#ref-dropdown')) { const originalId = target.dataset.originalId; const originalBlock = songData.song_blocks.find(b => b.id === originalId); if(originalBlock) { songData.song_blocks.push({ id: `block_${Date.now()}`, type: 'reference', label: `Reference to ${originalBlock.label}`, originalId: originalId }); renderSongBlocks(); } document.getElementById('ref-dropdown').classList.add('hidden'); }
            else if (target.dataset.action === 'add') { const type = target.dataset.type; const baseLabel = target.textContent.trim().replace('+', '').trim(); const count = songData.song_blocks.filter(b => b.label.startsWith(baseLabel)).length + 1; const label = `${baseLabel} ${count}`; const newBlock = { id: `block_${Date.now()}`, type, label }; if (type === 'lyrics') newBlock.content = ''; if (type === 'tab') { newBlock.data = { notes: [] }; newBlock.strings = 6; } songData.song_blocks.push(newBlock); renderSongBlocks(); }
        });
        recordBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        songSelector.addEventListener('change', () => loadSong(songSelector.value === 'new' ? null : songSelector.value));
        setlistBtn.addEventListener('click', () => setlistModal.classList.remove('hidden'));
        closeSetlistModalBtn.addEventListener('click', () => setlistModal.classList.add('hidden'));

        (function main(){
            populateTuningSelector(); 
            loadSheetList();
            loadChords();
            initializeNewSong();
        })();
    }
    </script>
</body>
</html>
