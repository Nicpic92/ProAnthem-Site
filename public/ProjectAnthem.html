<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Anthem - Block Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        body { font-family: Inter, system-ui, sans-serif; background-color: #242424; color: rgba(255, 255, 255, 0.87); }
        .form-input, .form-select, .form-textarea { background: #2f2f2f; border: 1px solid #555; border-radius: 6px; padding: 0.5rem 1rem; color: white; width: 100%; resize: none; }
        .live-preview { font-family: 'Courier New', Courier, monospace; line-height: 1.6; white-space: pre; background-color: #1e1e1e; padding: 1rem; border-radius: 6px; border: 1px solid #4a4a4a; }
        .live-preview-chords { color: #f2c94c; }
        .tab-preview { margin-top: 1rem; border-top: 1px dashed #4a4a4a; padding-top: 1rem; color: #a5b4fc; }
        .btn { border: 1px solid transparent; padding: 0.6em 1.2em; font-size: 1em; font-weight: 500; cursor: pointer; transition: background-color 0.25s; border-radius: 8px; }
        .btn:disabled { background-color: #4b5563; opacity: 0.5; cursor: not-allowed; }
        .btn-sm { padding: 0.3em 0.8em; font-size: 0.9em; }
        .btn-primary { background-color: #535bf2; color: white; } .btn-primary:hover:not(:disabled) { background-color: #646cff; }
        .btn-secondary { background-color: #4b5563; color: white; } .btn-secondary:hover:not(:disabled) { background-color: #6b7280; }
        .btn-danger { background-color: #b91c1c; color: white; } .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
        .hidden { display: none; }
        .song-block { background-color: #2d3748; border: 1px solid #4a5568; border-radius: 8px; margin-bottom: 1rem; }
        .block-header { background-color: #4a5568; padding: 0.5rem 1rem; display: flex; justify-content: space-between; align-items: center; cursor: grab; border-top-left-radius: 7px; border-top-right-radius: 7px; }
        .block-header:active { cursor: grabbing; }
        .block-content { padding: 1rem; position: relative; padding-bottom: 1.5rem; }
        .fretboard-wrapper { overflow-x: auto; border: 1px solid #555; border-radius: 6px; }
        .fretboard-string { stroke: #9ca3af; stroke-width: 2px; }
        .fretboard-note { fill: #facc15; cursor: grab; transition: fill 0.2s; }
        .fretboard-note:active { cursor: grabbing; }
        .fretboard-note.selected { fill: #ef4444; stroke: white; stroke-width: 2px; }
        .fretboard-note-text { fill: #111827; font-weight: bold; pointer-events: none; text-anchor: middle; alignment-baseline: central; }
        .queue-pill { background-color: #374151; padding: 2px 8px; border-radius: 12px; font-size: 0.9em; }
        .queue-pill.next { background-color: #535bf2; font-weight: bold; }
        .form-textarea.placement-mode { cursor: crosshair; }
        .drum-tab-block { font-family: 'Courier New', Courier, monospace; line-height: 1.5; }
        .resize-handle { position: absolute; bottom: 0; left: 0; right: 0; height: 10px; cursor: ns-resize; border-bottom-left-radius: 6px; border-bottom-right-radius: 6px; background-color: rgba(74, 85, 104, 0.5); }
        .resize-handle:hover { background-color: rgba(99, 110, 129, 0.7); }
        .btn-edit-mode { background-color: #2563eb; } .btn-edit-mode:hover { background-color: #1d4ed8; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 50; }
        .modal-content { background: #2d3748; padding: 2rem; border-radius: 8px; width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto;}
        .sortable-ghost { opacity: 0.4; background: #4a5568; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="access-denied" class="hidden text-center p-20">
        <h2 class="text-3xl font-bold text-red-500">Subscription Required</h2>
        <p class="mt-4 text-lg text-gray-300">Your trial has ended or your subscription is inactive.</p>
        <a href="/pricing.html" class="mt-6 inline-block bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-indigo-700">Manage Subscription</a>
    </div>

    <div id="tool-content" class="max-w-6xl mx-auto hidden">
        <header class="border-b border-gray-700 pb-4 mb-6 flex justify-between items-center">
             <a href="/proanthem_index.html" class="flex items-center space-x-4">
                <img src="/assets/logo_pa.jpg" alt="ProAnthem Logo" class="h-12">
                <h1 class="text-4xl font-bold">Project Anthem</h1>
            </a>
            <div id="nav-auth-section">
                <button id="logoutBtn" class="btn btn-secondary">Log Out</button>
            </div>
        </header>
        <main class="grid grid-cols-1 md:grid-cols-4 gap-8">
            <aside id="sidebar" class="md:col-span-1 h-full">
                <div class="sticky top-8 flex flex-col space-y-6 max-h-[90vh] overflow-y-auto pr-2">
                    <!-- Song Actions -->
                    <div class="space-y-2 flex-shrink-0">
                        <label for="songSelector" class="block text-sm font-medium text-gray-300 mb-1">Load Song</label>
                        <select id="songSelector" class="form-select"></select>
                        <button id="saveBtn" class="btn btn-primary w-full">Save Song</button>
                        <button id="setlistBtn" class="btn btn-secondary w-full">Setlists</button>
                        <a href="/band.html" id="manageBandBtn" class="btn btn-secondary w-full text-center" style="display: none;">Manage Band</a>
                        <a href="/pricing.html" class="btn btn-secondary w-full text-center block">Manage Subscription</a>
                        <button id="deleteBtn" class="btn btn-danger w-full">Delete Song</button>
                        <div id="statusMessage" class="text-center text-sm text-gray-400 h-4"></div>
                    </div>
                    <!-- Chord Palette & Musical Settings -->
                    <div class="space-y-6 flex-shrink-0">
                        <div class="space-y-3 pt-4 border-t border-gray-700">
                            <h3 class="font-semibold text-lg">Chord Palette</h3>
                            <p class="text-xs text-gray-400">Click to insert. Ctrl/Cmd+Click to add to queue.</p>
                            <div id="chordPalette" class="flex flex-wrap gap-2"></div>
                            <div class="flex gap-2">
                                <input type="text" id="newChordInput" class="form-input text-sm" placeholder="e.g. F#m7">
                                <button id="addChordBtn" class="btn btn-secondary btn-sm whitespace-nowrap">Add</button>
                            </div>
                        </div>
                        <div class="space-y-3 pt-4 border-t border-gray-700">
                            <h3 class="font-semibold text-lg">Musical Settings</h3>
                            <div class="space-y-2 text-right">
                                <div>
                                    <label for="tuningSelector" class="block text-sm font-medium text-gray-400 mb-1">Tuning</label>
                                    <select id="tuningSelector" class="form-select form-input text-sm"></select>
                                </div>
                                <div>
                                    <label for="capoFretInput" class="block text-sm font-medium text-gray-400 mb-1">Capo Fret</label>
                                    <input type="number" id="capoFretInput" class="form-input text-sm w-24 ml-auto" value="0" min="0" max="12">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-400 mb-1">Transpose All Chords</label>
                                    <div class="flex items-center gap-2 justify-end">
                                        <button id="transposeDownBtn" class="btn btn-secondary btn-sm">-</button>
                                        <span id="transposeStatus" class="font-bold text-lg w-8 text-center">0</span>
                                        <button id="transposeUpBtn" class="btn btn-secondary btn-sm">+</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
            <div class="md:col-span-3 space-y-4">
                <input type="text" id="titleInput" class="form-input text-xl" placeholder="Song Title">
                <input type="text" id="artistInput" class="form-input" placeholder="Artist Name">
                
                <div id="audioSection" class="p-4 bg-gray-900 rounded-md space-y-3">
                    <h3 class="text-lg font-semibold">Voice Memo</h3>
                    <div id="audioPlayerContainer" class="hidden">
                        <audio id="audioPlayer" controls class="w-full"></audio>
                    </div>
                    <div class="flex items-center gap-4">
                        <button id="recordBtn" class="btn btn-record">Record</button>
                        <button id="stopBtn" class="btn btn-secondary" disabled>Stop</button>
                        <span id="recordingStatus" class="text-gray-400"></span>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-semibold mb-2">Live Preview</h3>
                    <div id="livePreview" class="live-preview min-h-[100px] overflow-x-auto"></div>
                </div>
                
                <div class="mb-2">
                    <label class="block text-sm font-medium text-gray-400 mb-1">Chord Queue (Click in a lyrics block to place)</label>
                    <div class="flex items-center gap-2 p-2 bg-gray-900 rounded-md min-h-[40px]">
                        <div id="chordQueue" class="flex flex-wrap gap-2 flex-grow"></div>
                        <button id="clearQueueBtn" class="btn btn-danger btn-sm">Clear</button>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-semibold mb-2">Song Builder</h3>
                    <div id="song-blocks-container" class="space-y-4"></div>
                    <div id="add-block-buttons" class="mt-4 flex flex-wrap gap-2"></div>
                </div>
            </div>
        </main>
    </div>

    <div id="setlistModal" class="modal-overlay hidden">
        <div class="modal-content space-y-4">
            <div class="flex justify-between items-center"><h2 class="text-2xl font-bold">Setlist Manager</h2><button id="closeSetlistModalBtn" class="text-2xl">&times;</button></div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="setlistSelector" class="block text-sm font-medium text-gray-300 mb-1">Select Setlist</label>
                    <select id="setlistSelector" class="form-select"></select>
                </div>
                <div>
                    <label for="newSetlistInput" class="block text-sm font-medium text-gray-300 mb-1">Or Create New</label>
                    <div class="flex gap-2"><input type="text" id="newSetlistInput" class="form-input"><button id="createSetlistBtn" class="btn btn-primary">Create</button></div>
                </div>
            </div>
            <div id="setlistDetailsSection" class="hidden space-y-3 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-lg font-semibold">Gig Details</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label for="setlistVenue" class="block text-sm">Venue</label><input type="text" id="setlistVenue" class="form-input"></div>
                    <div><label for="setlistDate" class="block text-sm">Date</label><input type="date" id="setlistDate" class="form-input"></div>
                </div>
                <div><label for="setlistLogoUrl" class="block text-sm">Band Logo Image URL (for watermark)</label><input type="text" id="setlistLogoUrl" class="form-input" placeholder="https://.../logo.png"></div>
                <div><label for="setlistNotes" class="block text-sm">Notes</label><textarea id="setlistNotes" class="form-input" rows="2"></textarea></div>
                <div class="text-right"><button id="saveSetlistDetailsBtn" class="btn btn-primary btn-sm">Save Details</button></div>
            </div>
            <div class="bg-gray-800 p-4 rounded-md">
                <h3 id="currentSetlistTitle" class="text-xl font-semibold mb-2">Select a setlist</h3>
                <p class="text-sm text-gray-400 mb-2">Drag and drop songs to reorder.</p>
                <ul id="songsInSetlist" class="space-y-2"></ul>
            </div>
            <div class="flex justify-end gap-2 flex-wrap">
                <button id="deleteSetlistBtn" class="btn btn-danger" disabled>Delete Setlist</button>
                <button id="printDrummerSetlistBtn" class="btn btn-secondary" disabled>Print for Drummer</button>
                <button id="printSetlistBtn" class="btn btn-secondary" disabled>Print Full Band</button>
                <button id="addSongToSetlistBtn" class="btn btn-primary" disabled>Add Current Song to Setlist</button>
            </div>
        </div>
    </div>
    
    <div id="fret-selection-modal" class="hidden fixed z-50 bg-gray-800 border border-gray-600 rounded-lg shadow-xl p-4 space-y-2">
        <label for="fret-number-selector" class="text-sm text-gray-300">Select Fret:</label>
        <select id="fret-number-selector" class="form-select text-sm w-full"></select>
        <div class="flex justify-end gap-2">
            <button id="cancel-fret-btn" class="btn btn-secondary btn-sm">Cancel</button>
            <button id="add-fret-btn" class="btn btn-primary btn-sm">Add</button>
        </div>
    </div>

    <script src="/auth_proanthem.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if (checkAccess()) {
                initializeApp();
            }
        });
        
        function initializeApp() {
            let songData = { id: null, title: '', artist: '', audio_url: null, song_blocks: [] };
            let musicalContext = { tuning: 'E_STANDARD', capo: 0, transpose: 0 };
            let chordQueue = [];
            let chordQueueIndex = 0;
            let lastFocusedLyricsBlock = null;
            let mediaRecorder, audioChunks = [];
            let fretSelectionContext = { blockId: null, string: null, position: null };
            let selectedNote = { blockId: null, noteIndex: null };
            let activeResize = { element: null, startY: 0, startHeight: 0 };
            let isDraggingNote = false;

            const titleInput = document.getElementById('titleInput');
            const artistInput = document.getElementById('artistInput');
            const songBlocksContainer = document.getElementById('song-blocks-container');
            const addBlockButtonsContainer = document.getElementById('add-block-buttons');
            const livePreview = document.getElementById('livePreview');
            const tuningSelector = document.getElementById('tuningSelector');
            const capoFretInput = document.getElementById('capoFretInput');
            const songSelector = document.getElementById('songSelector');
            const saveBtn = document.getElementById('saveBtn');
            const deleteBtn = document.getElementById('deleteBtn');
            const logoutBtn = document.getElementById('logoutBtn');
            const statusMessage = document.getElementById('statusMessage');
            const chordPalette = document.querySelector('#sidebar #chordPalette');
            const newChordInput = document.querySelector('#sidebar #newChordInput');
            const addChordBtn = document.querySelector('#sidebar #addChordBtn');
            const transposeDownBtn = document.getElementById('transposeDownBtn');
            const transposeUpBtn = document.getElementById('transposeUpBtn');
            const transposeStatus = document.getElementById('transposeStatus');
            const chordQueueDiv = document.getElementById('chordQueue');
            const clearQueueBtn = document.getElementById('clearQueueBtn');
            const setlistBtn = document.getElementById('setlistBtn');
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const recordingStatus = document.getElementById('recordingStatus');
            
            const setlistModal = document.getElementById('setlistModal');
            const closeSetlistModalBtn = document.getElementById('closeSetlistModalBtn');
            const setlistSelector = document.getElementById('setlistSelector');
            const createSetlistBtn = document.getElementById('createSetlistBtn');
            const addSongToSetlistBtn = document.getElementById('addSongToSetlistBtn');
            const printSetlistBtn = document.getElementById('printSetlistBtn');
            const newSetlistInput = document.getElementById('newSetlistInput');
            const songsInSetlist = document.getElementById('songsInSetlist');
            const currentSetlistTitle = document.getElementById('currentSetlistTitle');
            const setlistDetailsSection = document.getElementById('setlistDetailsSection');
            const saveSetlistDetailsBtn = document.getElementById('saveSetlistDetailsBtn');
            const deleteSetlistBtn = document.getElementById('deleteSetlistBtn');
            const printDrummerSetlistBtn = document.getElementById('printDrummerSetlistBtn');

            const fretSelectionModal = document.getElementById('fret-selection-modal');
            const fretNumberSelector = document.getElementById('fret-number-selector');
            const addFretBtn = document.getElementById('add-fret-btn');
            const cancelFretBtn = document.getElementById('cancel-fret-btn');
            
            const TUNINGS = { 
                E_STANDARD: { name: "E Standard", offset: 0, strings: ['e', 'B', 'G', 'D', 'A', 'E'] }, 
                EB_STANDARD: { name: "Eb Standard", offset: -1, strings: ['d#', 'A#', 'F#', 'C#', 'G#', 'D#'] }, 
                D_STANDARD: { name: "D Standard", offset: -2, strings: ['d', 'A', 'F', 'C', 'G', 'D'] }, 
                DROP_D: { name: "Drop D", offset: 0, strings: ['e', 'B', 'G', 'D', 'A', 'D'] }, 
                DROP_C: { name: "Drop C", offset: -2, strings: ['d', 'A', 'F', 'C', 'G', 'C'] } 
            };

            const STRING_CONFIG = {
                6: { height: 180, stringSpacing: 28 },
                7: { height: 210, stringSpacing: 28 },
                8: { height: 240, stringSpacing: 28 }
            };
            const FRETBOARD_CONFIG = { frets: 24, width: 8000, nutWidth: 15, fretSpacing: 80, dotFrets: [3, 5, 7, 9, 12, 15, 17, 19, 21, 24], dotRadius: 5, noteRadius: 11 };
            const sharpScale = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
            
            const api = { 
                request: async (endpoint, options = {}) => {
                    const token = localStorage.getItem('user_token');
                    if (!token) { setStatus('You are not logged in.', true); window.location.href = '/proanthem_index.html'; throw new Error('No token found'); }
                    const url = `/api${endpoint}`;
                    const config = { headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}`}, ...options };
                    if(options.body) config.body = options.body;
                    if(options.method) config.method = options.method;
                    const response = await fetch(url, config);
                    if (!response.ok) {
                        if (response.status === 401) { setStatus('Session expired. Please log in.', true); localStorage.removeItem('user_token'); window.location.href = '/proanthem_index.html'; }
                        const err = await response.json().catch(() => ({ message: response.statusText })); throw new Error(err.message);
                    }
                    return response.status === 204 ? null : response.json();
                },
                getSheets: () => api.request('/lyric-sheets', { method: 'GET' }),
                getSheet: (id) => api.request(`/lyric-sheets/${id}`, { method: 'GET' }),
                createSheet: (data) => api.request('/lyric-sheets', { method: 'POST', body: JSON.stringify(data) }),
                updateSheet: (id, data) => api.request(`/lyric-sheets/${id}`, { method: 'PUT', body: JSON.stringify(data) }),
                deleteSheet: (id) => api.request(`/lyric-sheets/${id}`, { method: 'DELETE' }),
                getChords: () => api.request('/chords', { method: 'GET' }),
                createChord: (data) => api.request('/chords', { method: 'POST', body: JSON.stringify(data) }),
                getSetlists: () => api.request('/setlists', { method: 'GET' }),
                getSetlist: (id) => api.request(`/setlists/${id}`, { method: 'GET' }),
                createSetlist: (data) => api.request('/setlists', { method: 'POST', body: JSON.stringify(data) }),
                deleteSetlist: (id) => api.request(`/setlists/${id}`, { method: 'DELETE' }),
                addSongToSetlist: (setlistId, songId) => api.request(`/setlists/${setlistId}/songs`, { method: 'POST', body: JSON.stringify({ song_id: songId }) }),
                removeSongFromSetlist: (setlistId, songId) => api.request(`/setlists/${setlistId}/songs/${songId}`, { method: 'DELETE' }),
                updateSetlistDetails: (id, data) => api.request(`/setlists/${id}`, { method: 'PUT', body: JSON.stringify(data) }),
                updateSetlistSongOrder: (id, song_ids) => api.request(`/setlists/${id}/songs`, { method: 'PUT', body: JSON.stringify({ song_ids }) }) 
            };
            
            async function openSetlistManager() {
                setlistModal.classList.remove('hidden');
                await loadSetlists();
                handleSetlistSelection(null);
            }

            async function loadSetlists(selectId = null) {
                try {
                    const lists = await api.getSetlists();
                    setlistSelector.innerHTML = '<option value="">-- Select a Setlist --</option>';
                    lists.forEach(list => {
                        const option = document.createElement('option');
                        option.value = list.id;
                        option.textContent = list.name;
                        setlistSelector.appendChild(option);
                    });
                    if (selectId) {
                        setlistSelector.value = selectId;
                        await handleSetlistSelection(selectId);
                    }
                } catch (error) {
                    setStatus('Failed to load setlists.', true);
                }
            }

            async function handleSetlistSelection(setlistId) {
                if (!setlistId) {
                    currentSetlistTitle.textContent = 'Select a setlist';
                    setlistDetailsSection.classList.add('hidden');
                    songsInSetlist.innerHTML = '';
                    addSongToSetlistBtn.disabled = true;
                    printSetlistBtn.disabled = true;
                    printDrummerSetlistBtn.disabled = true;
                    deleteSetlistBtn.disabled = true;
                    return;
                }
                try {
                    const setlist = await api.getSetlist(setlistId);
                    currentSetlistTitle.textContent = setlist.name;
                    document.getElementById('setlistVenue').value = setlist.venue || '';
                    document.getElementById('setlistDate').value = setlist.event_date ? setlist.event_date.split('T')[0] : '';
                    document.getElementById('setlistLogoUrl').value = setlist.logo_url || '';
                    document.getElementById('setlistNotes').value = setlist.notes || '';
                    setlistDetailsSection.classList.remove('hidden');
                    songsInSetlist.innerHTML = '';
                    (setlist.songs || []).forEach(song => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center p-2 bg-gray-700 rounded';
                        li.dataset.songId = song.id;
                        li.innerHTML = `<span>${song.title} - <em class="text-gray-400">${song.artist}</em></span><button data-action="remove-song" class="btn btn-danger btn-sm">Remove</button>`;
                        songsInSetlist.appendChild(li);
                    });
                    addSongToSetlistBtn.disabled = !songData.id;
                    printSetlistBtn.disabled = false;
                    printDrummerSetlistBtn.disabled = false;
                    deleteSetlistBtn.disabled = false;
                } catch (error) {
                    setStatus(`Failed to load setlist details: ${error.message}`, true);
                }
            }
            
            async function handleSaveSetlistDetails() {
                const setlistId = setlistSelector.value;
                if (!setlistId) return;
                const payload = {
                    name: currentSetlistTitle.textContent,
                    venue: document.getElementById('setlistVenue').value,
                    event_date: document.getElementById('setlistDate').value,
                    logo_url: document.getElementById('setlistLogoUrl').value,
                    notes: document.getElementById('setlistNotes').value
                };
                try {
                    await api.updateSetlistDetails(setlistId, payload);
                    setStatus('Setlist details saved!', false);
                } catch (error) {
                    setStatus(`Error saving details: ${error.message}`, true);
                }
            }

            async function handleCreateSetlist() {
                const name = newSetlistInput.value.trim();
                if (!name) return alert('Please enter a name for the new setlist.');
                try {
                    const newSetlist = await api.createSetlist({ name });
                    newSetlistInput.value = '';
                    setStatus('Setlist created!', false);
                    await loadSetlists(newSetlist.id);
                } catch (error) {
                    setStatus(`Error creating setlist: ${error.message}`, true);
                }
            }

            async function handleDeleteSetlist() {
                const setlistId = setlistSelector.value;
                const setlistName = setlistSelector.options[setlistSelector.selectedIndex].text;
                if (!setlistId) return;
                if (confirm(`ARE YOU SURE you want to permanently delete the setlist "${setlistName}"? This cannot be undone.`)) {
                    try {
                        await api.deleteSetlist(setlistId);
                        setStatus(`Setlist "${setlistName}" deleted.`, false);
                        await loadSetlists();
                        handleSetlistSelection(null);
                    } catch(error) {
                        setStatus(`Failed to delete setlist: ${error.message}`, true);
                    }
                }
            }
            
            async function handleAddSongToSetlist() {
                const setlistId = setlistSelector.value;
                if (!songData.id) return alert('Please save the current song before adding it to a setlist.');
                if (!setlistId) return alert('Please select a setlist first.');
                try {
                    await api.addSongToSetlist(setlistId, songData.id);
                    setStatus(`'${songData.title}' added to setlist.`, false);
                    await handleSetlistSelection(setlistId);
                } catch(error) {
                    setStatus(`Failed to add song: ${error.message}`, true);
                }
            }
            
            async function handleRemoveSongFromSetlist(songId) {
                const setlistId = setlistSelector.value;
                if (!setlistId || !songId) return;
                if (confirm("Are you sure you want to remove this song from the setlist?")) {
                    try {
                        await api.removeSongFromSetlist(setlistId, songId);
                        setStatus(`Song removed from setlist.`, false);
                        await handleSetlistSelection(setlistId);
                    } catch(error) {
                        setStatus(`Failed to remove song: ${error.message}`, true);
                    }
                }
            }
            
            async function handlePrintSetlist(drummerMode = false) {
                const setlistId = setlistSelector.value;
                if (!setlistId) return;

                setStatus('Generating PDF...');
                try {
                    const setlist = await api.getSetlist(setlistId);
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    const leftMargin = 15;
                    const rightMargin = doc.internal.pageSize.getWidth() - 15;
                    let y = 20;
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const marginBottom = 20;
                    const maxWidth = rightMargin - leftMargin;

                    const getImageDataUrl = async (url) => {
                        if (!url) return Promise.resolve(null);
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.crossOrigin = 'Anonymous';
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                resolve(canvas.toDataURL('image/png'));
                            };
                            img.onerror = () => { console.error('Failed to load watermark image.'); resolve(null); };
                            img.src = url;
                        });
                    };
                    
                    const logoDataUrl = await getImageDataUrl(setlist.logo_url);
                    
                    const addWatermarkToPage = () => {
                        if (logoDataUrl) {
                            doc.setGState(new doc.GState({opacity: 0.1}));
                            doc.addImage(logoDataUrl, 'PNG', rightMargin - 20, 10, 20, 20);
                            doc.setGState(new doc.GState({opacity: 1.0}));
                        }
                    };

                    const checkPageBreak = (neededHeight) => {
                        if (y + neededHeight > pageHeight - marginBottom) {
                            addWatermarkToPage(); doc.addPage(); y = 20; addWatermarkToPage();
                        }
                    };

                    addWatermarkToPage();
                    doc.setFontSize(26);
                    doc.text(setlist.name, doc.internal.pageSize.getWidth() / 2, y, { align: 'center', maxWidth });
                    y += 15;
                    doc.setFontSize(16);
                    if (setlist.venue) { doc.text(setlist.venue, doc.internal.pageSize.getWidth() / 2, y, { align: 'center', maxWidth }); y += 8; }
                    if (setlist.event_date) { doc.text(new Date(setlist.event_date).toLocaleDateString(undefined, { timeZone: 'UTC' }), doc.internal.pageSize.getWidth() / 2, y, { align: 'center' }); }
                    y += 15;
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    doc.text('Song List:', leftMargin, y);
                    y += 8;
                    doc.setFont(undefined, 'normal');
                    (setlist.songs || []).forEach((song, index) => {
                        checkPageBreak(8);
                        const titleText = `${index + 1}. ${song.title} (${song.artist || 'Unknown'})`;
                        const splitTitle = doc.splitTextToSize(titleText, maxWidth - 5);
                        doc.text(splitTitle, leftMargin + 5, y);
                        y += splitTitle.length * 7;
                    });

                    for (const song of (setlist.songs || [])) {
                        addWatermarkToPage(); doc.addPage(); y = 20; addWatermarkToPage();
                        doc.setFontSize(18); doc.setFont(undefined, 'bold');
                        doc.text(song.title, leftMargin, y, { maxWidth });
                        y += 8;
                        doc.setFontSize(14); doc.setFont(undefined, 'italic');
                        doc.text(song.artist || 'Unknown Artist', leftMargin, y, { maxWidth });
                        y += 12;
                        
                        const songBlocks = (typeof song.song_blocks === 'string') ? JSON.parse(song.song_blocks || '[]') : (song.song_blocks || []);
                        for (const block of songBlocks) {
                            let blockToRender = block.type === 'reference' ? (songBlocks.find(b => b.id === block.originalId) || block) : block;
                            if (!blockToRender || (!blockToRender.content && (!blockToRender.data || !blockToRender.data.notes))) continue;
                            
                            if(drummerMode && !(blockToRender.type === 'lyrics' || blockToRender.type === 'drum_tab')) continue;
                            if(!drummerMode && blockToRender.type === 'drum_tab') continue;
                            
                            checkPageBreak(12);
                            doc.setFont(undefined, 'bold'); doc.setFontSize(12);
                            doc.text(block.label, leftMargin, y, { maxWidth });
                            y += 7;
                            
                            doc.setFont('Courier', 'normal'); doc.setFontSize(10);
                            const lineHeight = 5;

                            const contentToRender = blockToRender.type === 'tab' ? renderTransposedTab(blockToRender) : (blockToRender.content || '');

                            for (const line of contentToRender.split('\n')) {
                                if (blockToRender.type === 'lyrics') {
                                    const parsed = parseLineForRender(line.replace(/&nbsp;/g, ' '));
                                    if (!drummerMode) {
                                        checkPageBreak(lineHeight * 2.5);
                                        doc.setTextColor(60, 60, 60);
                                        doc.text(parsed.chordLine, leftMargin, y, { maxWidth });
                                        y += lineHeight;
                                    } else { checkPageBreak(lineHeight * 1.5); }
                                    doc.setTextColor(0, 0, 0);
                                    const splitLyrics = doc.splitTextToSize(parsed.lyricLine, maxWidth);
                                    doc.text(splitLyrics, leftMargin, y);
                                    y += (splitLyrics.length * lineHeight) + (lineHeight * 0.5);
                                } else if (blockToRender.type === 'tab' || blockToRender.type === 'drum_tab') {
                                    const splitText = doc.splitTextToSize(line, maxWidth);
                                    checkPageBreak(splitText.length * lineHeight);
                                    doc.setTextColor(0,0,0);
                                    doc.text(splitText, leftMargin, y);
                                    y += (splitText.length * lineHeight) + (lineHeight * 0.5);
                                }
                            }
                            y += lineHeight;
                        }
                    }
                    addWatermarkToPage();
                    doc.save(`${setlist.name.replace(/\s/g, '_')}${drummerMode ? '_Drummer' : ''}.pdf`);
                    setStatus('PDF generated.', false);
                } catch (error) {
                    setStatus(`Failed to generate PDF: ${error.message}`, true);
                    console.error("PDF generation error:", error);
                }
            }

            function renderSongBlocks() {
                songBlocksContainer.innerHTML = '';
                (songData.song_blocks || []).forEach(block => songBlocksContainer.appendChild(createBlockElement(block)));
                renderAddBlockButtons();
                renderPreview();
                initializeSortable();
            }

            function createBlockElement(block) {
                const div = document.createElement('div');
                div.className = 'song-block';
                div.dataset.blockId = block.id;
                let contentHtml = '', headerControls = '';
                const drumPlaceholder = `HH|x-x-x-x-x-x-x-x-|\nSD|----o-------o---|\nBD|o-------o-------|`;

                if (block.type === 'lyrics') {
                    contentHtml = `<textarea class="form-textarea lyrics-block" data-field="content" style="height: ${block.height || 100}px;" placeholder="Enter lyrics and [chords]...">${block.content || ''}</textarea><div class="resize-handle"></div>`;
                } else if (block.type === 'tab') {
                    contentHtml = `<div class="fretboard-wrapper"><div id="fretboard-${block.id}"></div></div>`;
                    const isEditMode = block.editMode || false;
                    const editButtonClass = isEditMode ? 'btn-edit-mode' : 'btn-secondary';
                    headerControls = `<button class="btn ${editButtonClass} btn-sm" data-action="edit-tab">${isEditMode ? 'Done Editing' : 'Edit'}</button>`;
                } else if (block.type === 'drum_tab') {
                    contentHtml = `<textarea class="form-textarea drum-tab-block" data-field="content" style="height: ${block.height || 100}px;" placeholder="${drumPlaceholder}">${block.content || ''}</textarea><div class="resize-handle"></div>`;
                } else if (block.type === 'reference') {
                    const originalBlock = songData.song_blocks.find(b => b.id === block.originalId);
                    contentHtml = `<div class="p-4 bg-gray-800 rounded-md text-gray-400 italic">Reference to: ${originalBlock ? originalBlock.label : 'Unknown Section'}</div>`;
                }
                div.innerHTML = `<div class="block-header"><div class="flex items-center gap-4"><div class="flex items-center gap-2"><span class="font-bold">${block.label}</span><span class="text-xs text-gray-400">(${block.type.replace('_', ' ')})</span></div></div><div class="flex items-center gap-2">${headerControls}<button class="btn-sm text-xs hover:underline" data-action="rename">Rename</button><button class="btn-sm text-red-400 hover:underline" data-action="delete">Delete</button></div></div><div class="block-content">${contentHtml}</div>`;
                if (block.type === 'tab') setTimeout(() => drawFretboard(block.id), 0);
                return div;
            }

            function renderAddBlockButtons() {
                const createdSections = songData.song_blocks.filter(b => b.type !== 'reference');
                let referenceButtonsHtml = '';
                if (createdSections.length > 0) {
                    referenceButtonsHtml = `<div class="relative inline-block text-left"><button id="insert-ref-btn" class="btn btn-secondary">Insert Existing Section</button><div id="ref-dropdown" class="hidden origin-top-right absolute left-0 mt-2 w-56 rounded-md shadow-lg bg-gray-700 ring-1 ring-black ring-opacity-5 z-10"><div class="py-1" role="menu" aria-orientation="vertical">${createdSections.map(b => `<a href="#" class="block px-4 py-2 text-sm text-gray-200 hover:bg-gray-600" data-original-id="${b.id}" role="menuitem">${b.label}</a>`).join('')}</div></div></div>`;
                }
                addBlockButtonsContainer.innerHTML = `<button class="btn btn-secondary" data-action="add" data-type="lyrics"> + Verse </button><button class="btn btn-secondary" data-action="add" data-type="lyrics"> + Chorus </button><button class="btn btn-secondary" data-action="add" data-type="lyrics"> + Bridge </button><button class="btn btn-secondary" data-action="add" data-type="tab"> + Tab Section </button><button class="btn btn-secondary" data-action="add" data-type="drum_tab"> + Drum Tab </button>${referenceButtonsHtml}`;
            }
            
            function renderPreview() {
                let previewHtml = '';
                (songData.song_blocks || []).forEach(block => {
                    let blockToRender = block.type === 'reference' ? (songData.song_blocks.find(b => b.id === block.originalId) || block) : block;
                    previewHtml += `<h4 class="text-lg font-bold mt-4 text-gray-400">${block.label}</h4>`;
                    if (!blockToRender) return;
                    
                    if (blockToRender.type === 'lyrics') {
                        (blockToRender.content || '').split('\n').forEach(line => {
                            const parsed = parseLineForRender(line);
                            previewHtml += `<div class="live-preview-chords">${parsed.chordLine}</div><div>${parsed.lyricLine}</div>`;
                        });
                    } else if (blockToRender.type === 'tab') {
                        previewHtml += `<div class="tab-preview">${renderTransposedTab(blockToRender)}</div>`;
                    } else if (blockToRender.type === 'drum_tab') {
                        previewHtml += `<div class="tab-preview">${blockToRender.content || ''}</div>`;
                    }
                });
                livePreview.innerHTML = previewHtml;
            }

            function getFretFromClick(evt, svgEl) {
                const wrapper = svgEl.closest('.fretboard-wrapper');
                if (!wrapper) return null;
                const svgRect = svgEl.getBoundingClientRect();
                const x = evt.clientX - svgRect.left + wrapper.scrollLeft;
                const y = evt.clientY - svgRect.top;
                const blockId = svgEl.id.split('-').pop();
                const block = songData.song_blocks.find(b => b.id === blockId);
                if (!block) return null;
                const numStrings = block.strings || 6;
                const stringConfig = STRING_CONFIG[numStrings];
                const stringIndex = Math.floor(y / stringConfig.stringSpacing);
                const rawFret = (x - FRETBOARD_CONFIG.nutWidth) / FRETBOARD_CONFIG.fretSpacing;
                const fret = Math.max(0, Math.round(rawFret));
                if (stringIndex >= 0 && stringIndex < numStrings && fret <= FRETBOARD_CONFIG.frets) {
                    return { string: stringIndex, fret, position: x };
                }
                return null;
            }


            function drawFretboard(blockId) {
                const container = document.getElementById(`fretboard-${blockId}`);
                if (!container) return;
                const block = songData.song_blocks.find(b => b.id === blockId);
                if (!block) return;
                const numStrings = block.strings || 6;
                const stringConfig = STRING_CONFIG[numStrings];
                const { frets, width, nutWidth, fretSpacing, dotFrets, dotRadius } = FRETBOARD_CONFIG;
                const { height, stringSpacing } = stringConfig;
                
                let svgHTML = `<svg id="fretboard-svg-${blockId}" width="${width}" height="${height}" style="min-width: 100%;"><rect class="fretboard-bg" width="${width}" height="${height}" fill="#2d3748" />`;
                for (let i = 0; i < numStrings; i++) {
                    svgHTML += `<line class="fretboard-string" x1="0" y1="${stringSpacing / 2 + i * stringSpacing}" x2="${width}" y2="${stringSpacing / 2 + i * stringSpacing}" />`;
                }
                svgHTML += `<rect class="fretboard-nut" x="0" y="0" width="${nutWidth}" height="${height}" fill="#1e1e1e" />`;
                for (let i = 1; i <= frets; i++) {
                    svgHTML += `<line class="fretboard-fret" x1="${nutWidth + i * fretSpacing}" y1="0" x2="${nutWidth + i * fretSpacing}" y2="${height}" stroke="#4a5563" stroke-width="1" />`;
                }
                dotFrets.forEach(fret => {
                    const x = nutWidth + (fret - 0.5) * fretSpacing;
                    if (fret % 12 === 0) {
                        svgHTML += `<circle class="fretboard-dot" cx="${x}" cy="${stringSpacing * (numStrings / 4)}" r="${dotRadius}" fill="#555" /><circle class="fretboard-dot" cx="${x}" cy="${height - (stringSpacing * (numStrings / 4))}" r="${dotRadius}" fill="#555" />`;
                    } else {
                        svgHTML += `<circle class="fretboard-dot" cx="${x}" cy="${height / 2}" r="${dotRadius}" fill="#555"/>`;
                    }
                });
                svgHTML += `<g id="fretboard-notes-group-${blockId}"></g></svg>`;
                container.innerHTML = svgHTML;
                drawNotesOnFretboard(blockId);
                const svgEl = document.getElementById(`fretboard-svg-${blockId}`);
                if (svgEl) attachFretboardListeners(svgEl);
            }

            function drawNotesOnFretboard(blockId) {
                const block = songData.song_blocks.find(b => b.id === blockId);
                const notesGroup = document.getElementById(`fretboard-notes-group-${blockId}`);
                if (!notesGroup || !block || block.type !== 'tab') return;
                notesGroup.innerHTML = '';
                const numStrings = block.strings || 6;
                const stringConfig = STRING_CONFIG[numStrings];
                const totalOffset = (TUNINGS[musicalContext.tuning]?.offset ?? 0) + musicalContext.capo;
                (block.data?.notes || []).forEach((note, index) => {
                    if (note.string >= numStrings) return;
                    const transposedFret = note.fret - totalOffset;
                    if (transposedFret < 0) return;
                    
                    const y = stringConfig.stringSpacing / 2 + note.string * stringConfig.stringSpacing;
                    const x = note.position;
                    
                    const isSelected = selectedNote.blockId === blockId && selectedNote.noteIndex === index;

                    notesGroup.innerHTML += `<g class="note-group"><circle class="fretboard-note ${isSelected ? 'selected' : ''}" cx="${x}" cy="${y}" r="${FRETBOARD_CONFIG.noteRadius}" data-note-index="${index}"/><text class="fretboard-note-text" x="${x}" y="${y}">${transposedFret}</text></g>`;
                });
            }
            
            function renderTransposedTab(tabBlock) {
                if (!tabBlock.data || !tabBlock.data.notes || tabBlock.data.notes.length === 0) return 'No tab data.';
                const numStrings = tabBlock.strings || 6;
                const tuningInfo = TUNINGS[musicalContext.tuning];
                const stringNames = tuningInfo?.strings?.slice(0, numStrings) || STRING_CONFIG[6].names;
                const totalOffset = (tuningInfo?.offset ?? 0) + musicalContext.capo + musicalContext.transpose;
                const positionMap = new Map();
                const sortedNotes = [...tabBlock.data.notes].sort((a,b) => a.position - b.position);

                sortedNotes.forEach(note => {
                    if (note.string >= numStrings) return;
                    const transposedFret = note.fret - totalOffset;
                    if (transposedFret < 0) return;
                    const charPosition = Math.floor((note.position - FRETBOARD_CONFIG.nutWidth) / 10);
                    if (charPosition < 0) return;
                    if (!positionMap.has(charPosition)) positionMap.set(charPosition, Array(numStrings).fill(null));
                    positionMap.get(charPosition)[note.string] = transposedFret;
                });
                if (positionMap.size === 0) return 'Notes out of range for current settings.';
                const sortedPositions = [...positionMap.keys()].sort((a,b) => a - b);
                const lines = stringNames.map(name => `${name.padEnd(2, ' ')}|`);
                let lastCharPos = 0;
                
                sortedPositions.forEach(charPos => {
                    const notesAtPos = positionMap.get(charPos);
                    const padding = charPos - lastCharPos;
                    if (padding > 1) lines.forEach((_, i) => lines[i] += '-'.repeat(padding - 1));
                    
                    let maxFretWidth = 1;
                    notesAtPos.forEach(fret => { if (fret !== null) maxFretWidth = Math.max(maxFretWidth, String(fret).length) });
                    
                    lines.forEach((_, i) => { lines[i] += (notesAtPos[i] !== null) ? String(notesAtPos[i]).padEnd(maxFretWidth, '-') : '-'.repeat(maxFretWidth) });
                    lastCharPos = charPos + maxFretWidth -1;
                });
                return lines.join('\n');
            }

            function updateBlockData(blockId, field, value, height) {
                const block = songData.song_blocks.find(b => b.id === blockId);
                if (block) {
                    if (field) block[field] = value;
                    if (height) block.height = height;
                    if(field === 'content') renderPreview();
                }
            }
            
            async function loadSong(id) {
                if (!id) { initializeNewSong(); return; }
                setStatus('Loading song...');
                try {
                    const data = await api.getSheet(id);
                    songData = { id: data.id, title: data.title || '', artist: data.artist || '', audio_url: data.audio_url, song_blocks: Array.isArray(data.song_blocks) ? data.song_blocks : [] };
                    titleInput.value = songData.title;
                    artistInput.value = songData.artist;
                    renderSongBlocks();
                    setStatus('Song loaded.');
                } catch (error) {
                    setStatus(`Error loading song: ${error.message}`, true);
                    initializeNewSong();
                }
            }

            function initializeNewSong() {
                songData = { id: null, title: '', artist: '', audio_url: null, song_blocks: [{ id: `block_${Date.now()}`, type: 'lyrics', label: 'Verse 1', content: '', height: 100 }] };
                titleInput.value = '';
                artistInput.value = '';
                songSelector.value = 'new';
                renderSongBlocks();
            }

            async function handleSave() {
                saveBtn.disabled = true;
                setStatus('Saving...');
                try {
                    songData.title = titleInput.value || 'Untitled';
                    songData.artist = artistInput.value || 'Unknown Artist';
                    const savedSong = songData.id ? await api.updateSheet(songData.id, songData) : await api.createSheet(songData);
                    songData.id = savedSong.id;
                    setStatus('Saved successfully!');
                    if (!songSelector.querySelector(`option[value="${savedSong.id}"]`)) { 
                        await loadSheetList();
                        songSelector.value = savedSong.id;
                    }
                } catch (error) { 
                    setStatus(`Save failed: ${error.message}`, true); 
                } finally {
                    saveBtn.disabled = false;
                }
            }
            
            function initializeSortable() {
                if (songBlocksContainer.sortableInstance) songBlocksContainer.sortableInstance.destroy();
                songBlocksContainer.sortableInstance = new Sortable(songBlocksContainer, {
                    animation: 150, handle: '.block-header', onEnd: (evt) => {
                        const [movedItem] = songData.song_blocks.splice(evt.oldIndex, 1);
                        songData.song_blocks.splice(evt.newIndex, 0, movedItem);
                        renderPreview();
                    }
                });
            }
            
            function setStatus(message, isError = false) { statusMessage.textContent = message; statusMessage.style.color = isError ? '#ef4444' : '#9ca3af'; if (message) setTimeout(() => statusMessage.textContent = '', 3000); }
            function parseLineForRender(rawLine) { let chordLine = ''; let lyricLine = ''; const regex = /(\[[^\]]+\])|([^\[]+)/g; let match; if (!rawLine.trim()) return { chordLine: ' ', lyricLine: ' ' }; while ((match = regex.exec(rawLine)) !== null) { if (match[1]) { const chordName = match[1].slice(1, -1); chordLine += chordName; lyricLine += ' '.repeat(chordName.length); } if (match[2]) { chordLine += ' '.repeat(match[2].length); lyricLine += match[2]; } } return { chordLine: chordLine.trimEnd() || ' ', lyricLine: lyricLine.trimEnd() || ' ' }; }
            function populateTuningSelector() { for (const key in TUNINGS) { const option = document.createElement('option'); option.value = key; option.textContent = TUNINGS[key].name; tuningSelector.appendChild(option); } }
            async function loadSheetList() { try { const songs = await api.getSheets(); songs.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at)); songSelector.innerHTML = '<option value="new">-- Create New Song --</option>'; songs.forEach(s => { const o = document.createElement('option'); o.value = s.id; o.textContent = s.title || 'Untitled'; songSelector.appendChild(o); }); } catch (e) { setStatus('Failed to load songs.', true); } }
            async function handleDelete() { if (!songData.id) { setStatus("Cannot delete an unsaved song.", true); return; } if (confirm(`Are you sure you want to delete "${songData.title}"?`)) { try { setStatus('Deleting...'); await api.deleteSheet(songData.id); setStatus('Song deleted.'); initializeNewSong(); await loadSheetList(); } catch (e) { setStatus(`Failed to delete: ${e.message}`, true); } } }
            function transposeChord(chord, amount) { const regex = /^([A-G][b#]?)(.*)/; const match = chord.match(regex); if (!match) return chord; let note = match[1]; let index = sharpScale.indexOf(note); if (index === -1) { const flatNotes = { 'Bb':'A#', 'Db':'C#', 'Eb':'D#', 'Gb':'F#', 'Ab':'G#'}; note = flatNotes[note] || note; index = sharpScale.indexOf(note); } if (index === -1) return chord; const newIndex = (index + amount + 12) % 12; return sharpScale[newIndex] + match[2]; }
            function updateTransposeStatus(steps) { musicalContext.transpose = steps; transposeStatus.textContent = steps > 0 ? `+${steps}` : steps; }
            function handleTranspose(amount) {
                updateTransposeStatus(musicalContext.transpose + amount);
                songData.song_blocks.forEach(block => {
                    if (block.type === 'lyrics' && block.content) {
                        block.content = block.content.replace(/\[([^\]]+)\]/g, (match, chord) => `[${transposeChord(chord, amount)}]`);
                    }
                });
                renderSongBlocks();
            }
            function renderChordQueue() {
                chordQueueDiv.innerHTML = '';
                if (chordQueue.length === 0) {
                    document.querySelectorAll('.lyrics-block').forEach(el => el.classList.remove('placement-mode'));
                    clearQueueBtn.disabled = true; return;
                }
                document.querySelectorAll('.lyrics-block').forEach(el => el.classList.add('placement-mode'));
                clearQueueBtn.disabled = false;
                chordQueue.forEach((name, index) => {
                    const pill = document.createElement('span');
                    pill.className = `queue-pill ${index === chordQueueIndex ? 'next' : ''}`;
                    pill.textContent = name;
                    chordQueueDiv.appendChild(pill);
                });
            }
            async function loadChords() { try { const chords = await api.getChords(); chordPalette.innerHTML = ''; chords.forEach(c => { const btn = document.createElement('button'); btn.className = 'btn btn-secondary btn-sm'; btn.onclick = (e) => { if (e.ctrlKey || e.metaKey) { chordQueue.push(c.name); renderChordQueue(); } else if (lastFocusedLyricsBlock) { const t = `[${c.name}]`; const p = lastFocusedLyricsBlock.selectionStart; lastFocusedLyricsBlock.value = lastFocusedLyricsBlock.value.slice(0, p) + t + lastFocusedLyricsBlock.value.slice(p); lastFocusedLyricsBlock.focus(); lastFocusedLyricsBlock.setSelectionRange(p + t.length, p + t.length); updateBlockData(lastFocusedLyricsBlock.closest('.song-block').dataset.blockId, 'content', lastFocusedLyricsBlock.value); }}; btn.textContent = c.name; chordPalette.appendChild(btn); }); } catch (e) { setStatus('Failed to load chords.', true); } }
            async function handleAddChord() { const name = newChordInput.value.trim(); if (!name) return; try { await api.createChord({ name }); newChordInput.value = ''; setStatus(`'${name}' added.`); await loadChords(); } catch (e) { setStatus(e.message, true); } }
            async function startRecording() { try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); mediaRecorder = new MediaRecorder(stream); mediaRecorder.ondataavailable = event => { audioChunks.push(event.data); }; mediaRecorder.onstop = handleSaveRecording; audioChunks = []; mediaRecorder.start(); recordBtn.textContent = 'Recording...'; recordBtn.classList.add('recording'); recordBtn.disabled = true; stopBtn.disabled = false; recordingStatus.textContent = 'Recording in progress.'; } catch (err) { setStatus('Microphone access denied.', true); console.error("Error accessing microphone:", err); } }
            function stopRecording() { if(mediaRecorder) mediaRecorder.stop(); recordBtn.textContent = 'Record'; recordBtn.classList.remove('recording'); recordBtn.disabled = false; stopBtn.disabled = true; recordingStatus.textContent = 'Processing...'; }
            async function handleSaveRecording() { const audioBlob = new Blob(audioChunks, { type: 'audio/webm' }); const formData = new FormData(); formData.append('file', audioBlob); formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET); const url = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/video/upload`; try { const response = await fetch(url, { method: 'POST', body: formData }); if (!response.ok) throw new Error('Upload to Cloudinary failed.'); const data = await response.json(); songData.audio_url = data.secure_url; await handleSave(); recordingStatus.textContent = 'Recording saved.'; document.getElementById('audioPlayerContainer').classList.remove('hidden'); document.getElementById('audioPlayer').src = data.secure_url; } catch (error) { setStatus('Failed to upload recording.', true); console.error("Upload error:", error); recordingStatus.textContent = ''; } }

            // Event listener setup
            const musicalInputs = [tuningSelector, capoFretInput];
            musicalInputs.forEach(el => el.addEventListener('input', () => {
                musicalContext.tuning = tuningSelector.value;
                musicalContext.capo = parseInt(capoFretInput.value, 10) || 0;
                renderSongBlocks();
            }));
            transposeUpBtn.addEventListener('click', () => handleTranspose(1));
            transposeDownBtn.addEventListener('click', () => handleTranspose(-1));
            saveBtn.addEventListener('click', handleSave);
            deleteBtn.addEventListener('click', handleDelete);
            logoutBtn.addEventListener('click', () => { logout() });
            addChordBtn.addEventListener('click', handleAddChord);
            newChordInput.addEventListener('keyup', (e) => e.key === 'Enter' && handleAddChord());
            clearQueueBtn.addEventListener('click', () => { chordQueue = []; chordQueueIndex = 0; renderChordQueue(); });
            songBlocksContainer.addEventListener('focusin', e => { if (e.target.classList.contains('lyrics-block')) lastFocusedLyricsBlock = e.target; });
            songBlocksContainer.addEventListener('input', e => { if (e.target.dataset.field) { const blockId = e.target.closest('.song-block').dataset.blockId; updateBlockData(blockId, 'content', e.target.value); } });
            
            function attachFretboardListeners(svgEl) {
                const blockId = svgEl.id.split('-').pop();
                const block = songData.song_blocks.find(b => b.id === blockId);
                if (!block) return;
                
                svgEl.addEventListener('mousedown', (e) => {
                    isDraggingNote = false; 
                    if (block.editMode && e.target.closest('.note-group')) {
                        isDraggingNote = true;
                        const noteGroup = e.target.closest('.note-group');
                        const noteIndex = parseInt(noteGroup.querySelector('.fretboard-note').dataset.noteIndex, 10);
                        selectedNote = { blockId, noteIndex };
                        drawNotesOnFretboard(blockId);
                    }
                });
                
                svgEl.addEventListener('click', (e) => {
                    if (isDraggingNote) { isDraggingNote = false; return; }
                    
                    const isNoteClick = e.target.closest('.note-group');
                    if (block.editMode) {
                        if (isNoteClick) {
                            const clickedNoteIndex = parseInt(isNoteClick.querySelector('.fretboard-note').dataset.noteIndex, 10);
                            if (selectedNote.blockId === blockId && selectedNote.noteIndex === clickedNoteIndex) {
                                block.data.notes.splice(clickedNoteIndex, 1);
                                selectedNote = { blockId: null, noteIndex: null };
                                renderPreview();
                            } else {
                                selectedNote = { blockId, noteIndex: clickedNoteIndex };
                            }
                        } else { 
                            selectedNote = { blockId: null, noteIndex: null };
                        }
                        drawNotesOnFretboard(blockId);
                    } else {
                        if (!isNoteClick) {
                            const clickData = getFretFromClick(e, svgEl);
                            if (clickData) {
                                fretSelectionContext = { blockId, string: clickData.string, position: clickData.position };
                                fretNumberSelector.innerHTML = '';
                                for (let i = 0; i <= FRETBOARD_CONFIG.frets; i++) {
                                    const option = new Option(i, i);
                                    if (i === clickData.fret) option.selected = true;
                                    fretNumberSelector.appendChild(option);
                                }
                                fretSelectionModal.style.left = `${e.clientX + 5}px`;
                                fretSelectionModal.style.top = `${e.clientY + 5}px`;
                                fretSelectionModal.classList.remove('hidden');
                            }
                        }
                    }
                });
            }
            
            document.addEventListener('mousemove', e => {
                if (activeResize.element) {
                    const height = activeResize.startHeight + e.clientY - activeResize.startY;
                    activeResize.element.style.height = `${Math.max(50, height)}px`;
                }
                if (isDraggingNote && selectedNote.blockId) {
                    const block = songData.song_blocks.find(b => b.id === selectedNote.blockId);
                    const note = block?.data?.notes[selectedNote.noteIndex];
                    if (note) {
                        const svg = document.getElementById(`fretboard-svg-${selectedNote.blockId}`);
                        const clickData = getFretFromClick(e, svg);
                        if (clickData) {
                           note.position = clickData.position;
                           note.string = clickData.string;
                           // The fret value does not change during drag
                           drawNotesOnFretboard(selectedNote.blockId);
                        }
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (activeResize.element) {
                    const newHeight = activeResize.element.offsetHeight;
                    updateBlockData(activeResize.blockId, null, null, newHeight);
                    activeResize = { element: null, startY: 0, startHeight: 0 };
                    document.body.style.cursor = '';
                }
                if(isDraggingNote) {
                    const block = songData.song_blocks.find(b => b.id === selectedNote.blockId);
                    const note = block?.data?.notes[selectedNote.noteIndex];
                    if (note) {
                         const rawFret = (note.position - FRETBOARD_CONFIG.nutWidth) / FRETBOARD_CONFIG.fretSpacing;
                         const finalFret = Math.max(0, Math.round(rawFret));
                         const totalOffset = (TUNINGS[musicalContext.tuning]?.offset ?? 0) + musicalContext.capo;
                         note.fret = finalFret + totalOffset;
                    }
                    isDraggingNote = false;
                    renderPreview(); 
                }
            });

            songBlocksContainer.addEventListener('click', (e) => {
                const blockEl = e.target.closest('.song-block');
                if (!blockEl) return;
                const blockId = blockEl.dataset.blockId;
                const block = songData.song_blocks.find(b => b.id === blockId);

                if (e.target.classList.contains('lyrics-block') && chordQueue.length > 0) {
                    e.preventDefault(); const textarea = e.target; const chordToPlace = chordQueue[chordQueueIndex]; 
                    const t = `[${chordToPlace}]`; const p = textarea.selectionStart; 
                    textarea.value = textarea.value.slice(0, p) + t + textarea.value.slice(p); 
                    textarea.focus(); const newPos = p + t.length; 
                    textarea.setSelectionRange(newPos, newPos); 
                    chordQueueIndex = (chordQueueIndex + 1) % chordQueue.length; 
                    updateBlockData(blockId, 'content', textarea.value); renderChordQueue(); 
                } else if (e.target.dataset.action === 'delete') { 
                    if (confirm('Are you sure?')) { songData.song_blocks = songData.song_blocks.filter(b => b.id !== blockId && b.originalId !== blockId); renderSongBlocks(); }
                } else if (e.target.dataset.action === 'rename') { 
                    const newLabel = prompt('Enter new label:', block.label); if (newLabel) { block.label = newLabel; renderSongBlocks(); }
                } else if (e.target.dataset.action === 'edit-tab') {
                    const button = e.target;
                    block.editMode = !block.editMode;
                    button.textContent = block.editMode ? 'Done Editing' : 'Edit';
                    button.classList.toggle('btn-secondary');
                    button.classList.toggle('btn-edit-mode');
                    if (!block.editMode && selectedNote.blockId === blockId) {
                        selectedNote = {blockId: null, noteIndex: null};
                        drawNotesOnFretboard(blockId);
                    }
                }
            });


            document.addEventListener('keydown', (e) => {
                if (!selectedNote.blockId || selectedNote.noteIndex === null) return;
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    const block = songData.song_blocks.find(b => b.id === selectedNote.blockId);
                    if (block && block.data && block.data.notes && block.data.notes[selectedNote.noteIndex]) {
                        block.data.notes.splice(selectedNote.noteIndex, 1);
                        const oldBlockId = selectedNote.blockId;
                        selectedNote = { blockId: null, noteIndex: null };
                        drawNotesOnFretboard(oldBlockId);
                        renderPreview();
                    }
                }
            });

            function confirmFretSelection() {
                const { blockId, string, position } = fretSelectionContext;
                const fret = parseInt(fretNumberSelector.value, 10);
                const block = songData.song_blocks.find(b => b.id === blockId);

                if(block && string !== null && position !== null && fret >= 0) {
                    const totalOffset = (TUNINGS[musicalContext.tuning]?.offset ?? 0) + musicalContext.capo;
                    if (!block.data) block.data = { notes: [] };
                    block.data.notes.push({ string, fret: fret + totalOffset, position });
                    drawNotesOnFretboard(blockId);
                    renderPreview();
                }
                fretSelectionModal.classList.add('hidden');
            }

            addBlockButtonsContainer.addEventListener('click', e => {
                const target = e.target;
                if (target.id === 'insert-ref-btn') { document.getElementById('ref-dropdown').classList.toggle('hidden'); }
                else if (target.closest('#ref-dropdown')) { const originalId = target.dataset.originalId; const originalBlock = songData.song_blocks.find(b => b.id === originalId); if(originalBlock) { songData.song_blocks.push({ id: `block_${Date.now()}`, type: 'reference', label: `Reference to ${originalBlock.label}`, originalId: originalId }); renderSongBlocks(); } document.getElementById('ref-dropdown').classList.add('hidden'); }
                else if (target.dataset.action === 'add') {
                    const type = target.dataset.type;
                    const baseLabel = target.textContent.trim().replace('+', '').trim();
                    const count = songData.song_blocks.filter(b => b.label.startsWith(baseLabel)).length + 1;
                    const label = `${baseLabel} ${count}`;
                    const newBlock = { id: `block_${Date.now()}`, type, label, height: 100 };
                    if (type === 'lyrics' || type === 'drum_tab') newBlock.content = '';
                    if (type === 'tab') { newBlock.data = { notes: [] }; newBlock.strings = 6; newBlock.editMode = false; }
                    songData.song_blocks.push(newBlock);
                    renderSongBlocks();
                }
            });
            
            recordBtn.addEventListener('click', startRecording);
            stopBtn.addEventListener('click', stopRecording);
            songSelector.addEventListener('change', () => loadSong(songSelector.value === 'new' ? null : songSelector.value));
            setlistBtn.addEventListener('click', openSetlistManager);
            closeSetlistModalBtn.addEventListener('click', () => setlistModal.classList.add('hidden'));
            setlistSelector.addEventListener('change', (e) => handleSetlistSelection(e.target.value));
            saveSetlistDetailsBtn.addEventListener('click', handleSaveSetlistDetails);
            createSetlistBtn.addEventListener('click', handleCreateSetlist);
            addSongToSetlistBtn.addEventListener('click', handleAddSongToSetlist);
            printSetlistBtn.addEventListener('click', () => handlePrintSetlist(false));
            printDrummerSetlistBtn.addEventListener('click', () => handlePrintSetlist(true));
            deleteSetlistBtn.addEventListener('click', handleDeleteSetlist);
            addFretBtn.addEventListener('click', confirmFretSelection);
            cancelFretBtn.addEventListener('click', () => fretSelectionModal.classList.add('hidden'));
            songsInSetlist.addEventListener('click', (e) => {
                if (e.target.dataset.action === 'remove-song') {
                    const songId = e.target.closest('li').dataset.songId;
                    handleRemoveSongFromSetlist(songId);
                }
            });

            (function main(){
                populateTuningSelector(); 
                loadSheetList();
                loadChords();
                initializeNewSong();
            })();
        }
    </script>
</body>
</html>
